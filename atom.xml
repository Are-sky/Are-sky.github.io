<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Helios Blog</title>
  
  <subtitle>即使没有月亮，心中也是一片皎洁。</subtitle>
  <link href="https://blog.hiles.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.hiles.cn/"/>
  <updated>2022-09-08T13:46:22.195Z</updated>
  <id>https://blog.hiles.cn/</id>
  
  <author>
    <name>Helios</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring基础</title>
    <link href="https://blog.hiles.cn/posts/d607e27b.html"/>
    <id>https://blog.hiles.cn/posts/d607e27b.html</id>
    <published>2022-09-08T13:22:32.000Z</published>
    <updated>2022-09-08T13:46:22.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring基础"><a href="#Spring基础" class="headerlink" title="Spring基础"></a>Spring基础</h1><h2 id="Spring系统架构"><a href="#Spring系统架构" class="headerlink" title="Spring系统架构"></a>Spring系统架构</h2><ul><li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p></li><li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整<br><img src="http://img.hiles.cn/image-20210729172153796.png" alt="image-20210729172153796"></p></li><li>Spring Framework 4的版本的系统结构图<br><img src="http://img.hiles.cn/1629720945720.png" alt="1629720945720"></li></ul><p>(1)核心层</p><ul><li>Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul><p>(2)AOP层</p><ul><li>AOP:面向切面编程，它依赖核心层容器，目的是==在不改变原有代码的前提下对其进行功能增强==</li><li>Aspects:AOP是思想,Aspects是对AOP思想的具体实现</li></ul><p>(3)数据层</p><ul><li>Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul><p>(4)Web层</p><ul><li>SpringMVC</li></ul><p>(5)Test层</p><ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul>]]></content>
    
    
    <summary type="html">Spring基础</summary>
    
    
    
    <category term="后台成长历程" scheme="https://blog.hiles.cn/categories/%E5%90%8E%E5%8F%B0%E6%88%90%E9%95%BF%E5%8E%86%E7%A8%8B/"/>
    
    
    <category term="java, springboot,redis" scheme="https://blog.hiles.cn/tags/java-springboot-redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="https://blog.hiles.cn/posts/4ebad2d4.html"/>
    <id>https://blog.hiles.cn/posts/4ebad2d4.html</id>
    <published>2022-09-07T13:44:11.000Z</published>
    <updated>2022-09-07T14:07:41.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><h2 id="1-现在pom-xml中导入Redis项目依赖"><a href="#1-现在pom-xml中导入Redis项目依赖" class="headerlink" title="1.现在pom.xml中导入Redis项目依赖"></a>1.现在pom.xml中导入Redis项目依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  redis  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-配置application配置文件"><a href="#2-配置application配置文件" class="headerlink" title="2.配置application配置文件"></a>2.配置application配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    redis:</span><br><span class="line">    database: <span class="number">0</span></span><br><span class="line">    # Redis服务器Ip地址</span><br><span class="line">    host: </span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    # 密码 默认为空</span><br><span class="line">    password: </span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: <span class="number">200</span></span><br><span class="line">        # 连接池最大阻塞等待时间（使用负值表示没有限制） 表示连接池的链接拿完了 现在去申请需要等待的时间</span><br><span class="line">        max-wait: -<span class="number">1</span></span><br><span class="line">        # 连接池中的最大空闲连接</span><br><span class="line">        max-idle: <span class="number">10</span></span><br><span class="line">        # 连接池中的最小空闲连接</span><br><span class="line">        min-idle: <span class="number">0</span></span><br><span class="line">    # 连接超时时间（毫秒） 去链接redis服务端</span><br><span class="line">    timeout: <span class="number">6000</span></span><br></pre></td></tr></table></figure><h2 id="3-开放端口"><a href="#3-开放端口" class="headerlink" title="3.开放端口"></a>3.开放端口</h2><h4 id="1-去自己的云服务器官网修改自己的服务器的安全组添加6379端口"><a href="#1-去自己的云服务器官网修改自己的服务器的安全组添加6379端口" class="headerlink" title="1. 去自己的云服务器官网修改自己的服务器的安全组添加6379端口"></a>1. 去自己的云服务器官网修改自己的服务器的安全组添加6379端口</h4><h4 id="2-在linux服务器编辑redis-conf配置文件，取消本地绑定，开启远程访问"><a href="#2-在linux服务器编辑redis-conf配置文件，取消本地绑定，开启远程访问" class="headerlink" title="2. 在linux服务器编辑redis.conf配置文件，取消本地绑定，开启远程访问"></a>2. 在linux服务器编辑redis.conf配置文件，取消本地绑定，开启远程访问</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到配置文件redis.conf，修改配置文件 输入whereis redis.conf可以找到文件位置</span></span><br><span class="line"><span class="comment">//开启远程连接（注释掉代表允许所有人访问）</span></span><br><span class="line">#bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -::<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启远程连接（允许所有人访问，由yes修改为no）</span></span><br><span class="line"><span class="keyword">protected</span>-mode no</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-编写RedisUtils工具类"><a href="#4-编写RedisUtils工具类" class="headerlink" title="4.编写RedisUtils工具类"></a>4.编写RedisUtils工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------key 相关操作---------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要删除的 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys 要删除的 键 的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Collection&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        redisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 判断该 键 是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在返回 true, 不存在返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     要设置的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功返回 true, 设置失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置在什么时间过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  要设置的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功返回 true, 设置失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">expireAt</span><span class="params">(String key, Date date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expireAt(key, date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找匹配的 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 匹配字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 满足匹配条件的 键 的 Set 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">keys</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前数据库的 key 移动到给定的数据库 db 当中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     要移动的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbIndex 要移动到的 db 的序号, 从 0 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移动成功返回 true, 移动失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">move</span><span class="params">(String key, <span class="type">int</span> dbIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.move(key, dbIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 key 的过期时间，key 将持久保持</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要移除过期时间的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除成功返回 true, 并且该 key 将持久存在, 移除失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">persist</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.persist(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 key 的剩余的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  要查询剩余过期时间的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间的单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 剩余的过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getExpire</span><span class="params">(String key, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 key 的剩余的过期时间, 默认时间单位: 秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要查询剩余过期时间的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 剩余的过期时间, 单位: 秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前数据库中随机返回一个 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 随机获取的 键 的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">randomKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.randomKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改 key 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldKey 修改前的 键 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newKey 修改后的 键 的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rename</span><span class="params">(String oldKey, String newKey)</span> &#123;</span><br><span class="line">        redisTemplate.rename(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅当 newKey 不存在时，将 oldKey 改名为 newKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldKey 修改前的 键 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newKey 修改后的 键 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改成功返回 true, 修改失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">renameIfAbsent</span><span class="params">(String oldKey, String newKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.renameIfAbsent(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 key 所储存的值的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要查询类型的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key 的数据类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataType <span class="title function_">type</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.type(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------string 相关操作---------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置指定 key 的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要设置的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要设置的 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定 key 的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 键 对应的 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 key 的 字符串值 中指定位置的 子字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要获取值的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置, 最小值: 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置, 最大值: 字符串 - 1, 若为 -1 则是获取整个字符串值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定 键 的 字符串值 的 子字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定 key 的值设为 value ，并返回 key 的旧值( old value )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要设置值的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 旧值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getAndSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 key 所储存的字符串值，获取指定偏移量上的位( bit )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定偏移量上的 位( 0 / 1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getBit</span><span class="params">(String key, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().getBit(key, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量获取 key 的 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys 要获取值的 键 的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key对应的值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">multiGet</span><span class="params">(Collection&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().multiGet(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置ASCII码, 字符串&#x27;a&#x27;的ASCII码是97, 转为二进制是&#x27;01100001&#x27;, 此方法是将二进制第 offset 位值变为 value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    要设置的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 偏移多少位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value  值, true 为 1,  false 为 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功返回 true, 设置失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">setBit</span><span class="params">(String key, <span class="type">long</span> offset, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().setBit(key, offset, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位, 天: TimeUnit.DAYS 小时: TimeUnit.HOURS 分钟: TimeUnit.MINUTES</span></span><br><span class="line"><span class="comment">     *                秒: TimeUnit.SECONDS 毫秒: TimeUnit.MILLISECONDS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEx</span><span class="params">(String key, Object value, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有在 key 不存在时设置 key 的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 之前已经存在返回 false, 不存在返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">setIfAbsent</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value  值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 从指定位置开始覆写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRange</span><span class="params">(String key, Object value, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字符串的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该 key 对应的 值的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">size</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加 key-value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maps key-value 的 map 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiSet</span><span class="params">(Map&lt;String, Object&gt; maps)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().multiSet(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在才会设置成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maps key-value 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 之前已经存在返回 false, 不存在返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">multiSetIfAbsent</span><span class="params">(Map&lt;String, Object&gt; maps)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().multiSetIfAbsent(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加(自增长), 负数则为自减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increment 自增量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">incrBy</span><span class="params">(String key, <span class="type">long</span> increment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自增长, 增长量为浮点数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increment 自增量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">incrByFloat</span><span class="params">(String key, <span class="type">double</span> increment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 value 追加到指定 key 的值的末尾</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要追加的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 追加值后新值的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">append</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().append(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------hash 相关操作-------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取存储在哈希表中指定字段的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field 字段名( 即 map 中的 key )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hGet</span><span class="params">(String key, String field)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取给定 哈希表 中的所有键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所有的 键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hGetAll</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定 哈希表 中所有给定字段的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fields 要获取值的字段集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表中所有给定字段的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">hMultiGet</span><span class="params">(String key, Collection&lt;Object&gt; fields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().multiGet(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向指定 哈希表 中存储一个 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey 字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hPut</span><span class="params">(String key, String hashKey, Object value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向指定 哈希表 中存储多个 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maps 键值对集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hPutAll</span><span class="params">(String key, Map&lt;String, Object&gt; maps)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().putAll(key, maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅当 hashKey 不存在时才设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey 字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功返回 true, 设置失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">hPutIfAbsent</span><span class="params">(String key, String hashKey, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().putIfAbsent(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除哈希表中一个或多个字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fields 要删除的字段集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除成功的数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">hDelete</span><span class="params">(String key, Object... fields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().delete(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看哈希表中指定的字段是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要查看的哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field 字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在返回 true, 不存在返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hExists</span><span class="params">(String key, String field)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为哈希表 key 中的指定字段的整数值加上增量 increment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       指定的哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field     字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increment 增加的量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">hIncrBy</span><span class="params">(String key, Object field, <span class="type">long</span> increment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, field, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为哈希表 key 中的指定字段的整数值加上增量 increment( 浮点型 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   指定的哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field 字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 增加的量( 浮点型 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">hIncrByFloat</span><span class="params">(String key, Object field, <span class="type">double</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, field, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有哈希表中的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所有的 字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">hKeys</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().keys(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希表中字段的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表所有字段的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">hSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希表中所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表中所有的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">hValues</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().values(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代哈希表中的键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> options 迭代的限制条件, 为 ScanOptions.NONE 则无限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个键值对元组的游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Cursor&lt;Entry&lt;Object, Object&gt;&gt; <span class="title function_">hScan</span><span class="params">(String key, ScanOptions options)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------list 相关操作----------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引获取列表中的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   元素所在的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 下标, 从 0 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表中指定下标的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表指定范围内的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   元素所在列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置, 0 是开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置, -1 返回所有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定索引范围内的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在 list 头部( 左边 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 存储的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPush</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个值存入列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值, 可以输入多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPushAll</span><span class="params">(String key, Object... value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个值存入列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPushAll</span><span class="params">(String key, Collection&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 list 存在的时候才加入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPushIfPresent</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 pivot 存在,在 pivot 前面添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pivot 基准值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要添加的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPush</span><span class="params">(String key, Object pivot, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在 list 尾部( 右边 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPush</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个值存入列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值, 可以输入多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPushAll</span><span class="params">(String key, Object... value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个值存入列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPushAll</span><span class="params">(String key, Collection&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为已存在的列表添加值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   存在的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPushIfPresent</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 pivot 元素的右边添加值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pivot 基准值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要添加的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPush</span><span class="params">(String key, Object pivot, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引设置列表元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lSet</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移出并获取列表的第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lLeftPop</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移出并获取列表的第一个元素, 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lBLeftPop</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并获取列表最后一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lRightPop</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移出并获取列表的最后一个元素, 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lBRightPop</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceKey      要移除元素的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destinationKey 要添加元素的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移动的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lRightPopAndLeftPush</span><span class="params">(String sourceKey, String destinationKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPopAndLeftPush(sourceKey, destinationKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它; 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceKey      要移除元素的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destinationKey 要添加元素的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout        等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit           时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移动的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lBRightPopAndLeftPush</span><span class="params">(String sourceKey, String destinationKey, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPopAndLeftPush(sourceKey, destinationKey, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除集合中值等于 value 的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index = 0, 删除所有值等于value的元素;</span></span><br><span class="line"><span class="comment">     *              index &gt; 0, 从头部开始删除第一个值等于 value 的元素;</span></span><br><span class="line"><span class="comment">     *              index &lt; 0, 从尾部开始删除第一个值等于 value 的元素;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().remove(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 裁剪 list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> &lt;a href=&quot;https://redis.io/commands/ltrim&quot;&gt;Redis Documentation: LTRIM&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lTrim</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().trim(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLen</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------set 相关操作--------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set 添加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值, 可以同时添加多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sAdd</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 要移除的元素, 可以同时移除多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并返回集合的一个随机元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中随机一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sPop</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().pop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素 value 从一个集合移到另一个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     被移除的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   要移除的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey 移动到的目标集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移动成功返回 true, 移动失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">sMove</span><span class="params">(String key, Object value, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().move(key, value, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断集合是否包含 value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含返回 true, 不包含返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">sIsMember</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个集合的交集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个集合的交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sIntersect</span><span class="params">(String key, String otherKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().intersect(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 集合与多个集合的交集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 多个集合的交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sIntersect</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().intersect(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与 otherKey 集合的交集存储到 destKey 集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sIntersectAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().intersectAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与多个集合的交集存储到 destKey 集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sIntersectAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().intersectAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个集合的并集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个集合的并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sUnion</span><span class="params">(String key, String otherKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 集合与多个集合的并集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 多个集合的并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sUnion</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与 otherKey 集合的并集存储到 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sUnionAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与多个集合的并集存储到 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sUnionAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个集合的差集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合1 - 集合2 的差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sDifference</span><span class="params">(String key, String otherKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().difference(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 集合与多个集合的差集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合1 - 集合2 - 集合3 - ... 集合n 的差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sDifference</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().difference(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与 otherKey 集合的差集存储到 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sDifference</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().differenceAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与多个集合的差集存储到 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sDifference</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().differenceAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合所有元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中所有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">setMembers</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机获取集合中的一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中随机一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sRandomMember</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().randomMember(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机获取集合中 count 个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 要获取的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> count 个随机元素组成的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">sRandomMembers</span><span class="params">(String key, <span class="type">long</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().randomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机获取集合中 count 个元素并且去除重复的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 要获取的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> count 个随机元素组成的集合, 并且不包含重复元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sDistinctRandomMembers</span><span class="params">(String key, <span class="type">long</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().distinctRandomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代集合中的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> options 迭代的限制条件, 为 ScanOptions.NONE 则无限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Cursor&lt;Object&gt; <span class="title function_">sScan</span><span class="params">(String key, ScanOptions options)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------zSet 相关操作--------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素, 有序集合是按照元素的 score 值由小到大排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> score 分数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 添加成功返回 true, 添加失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">zAdd</span><span class="params">(String key, Object value, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().add(key, value, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加多个元素到有序集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 多个元素值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 有序集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zAdd</span><span class="params">(String key, Set&lt;TypedTuple&lt;Object&gt;&gt; values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除有序集合中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 要移除的值, 可以同时移除多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 有序集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加元素的 score 值，并返回增加后的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要增加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 增加的分数是多少</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的分数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">zIncrementScore</span><span class="params">(String key, Object value, <span class="type">double</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().incrementScore(key, value, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回元素在集合的排名,有序集合是按照元素的 score 值由小到大排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排名, 从小到大顺序, 0 表示第一位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zRank</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回元素在集合的排名,按元素的 score 值由大到小排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排名, 从大到小顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zReverseRank</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合的元素, 从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置, -1 表示从开始位置开始后面的所有元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定区间的值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合元素, 并且把 score 值也获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置, -1 表示从开始位置开始后面的所有元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定区间的元素及分数的元组的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zRangeWithScores</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rangeWithScores(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数 在最小值与最大值之间的元素集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zRangeByScore</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素及其分数, 并按分数从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数 在最小值与最大值之间的元素与分数的元组的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zRangeByScoreWithScores</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素及其分数, 从小到大排序, 只获取 start 到 end 位置之间的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min   最低分数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max   最高分数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在 min 与 max 之间, 位置在 start 与 end 之间的元素与分数的元组的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zRangeByScoreWithScores</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合的元素, 从大到小排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 按照 分数 倒序的元素集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zReverseRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRange(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合的元素, 从大到小排序, 并返回 score 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定区间的元素及其分数的元组的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zReverseRangeWithScores</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeWithScores(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素, 从大到小排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在 min 与 max 之间的元素的集合, 按分数倒序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zReverseRangeByScore</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素, 从大到小排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在 min 与 max 之间的元素与分数的元组的集合, 按分数倒序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zReverseRangeByScoreWithScores</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素及其分数, 从小到大排序, 只获取 start 到 end 位置之间的结果, 按分数从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min   分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max   分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在 min 与 max 之间, 位置在 start 与 end 之间的元素与分数的元组的集合, 按分数倒序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zReverseRangeByScore</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScore(key, min, max, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值获取集合元素数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在最小值与最大值之间的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zCount</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().count(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合大小( 底层实现还是 zcard )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zZCard</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().zCard(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合中 value 元素的 score 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 元素值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该元素值的分数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">zScore</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().score(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除指定索引位置的成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zRemoveRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().removeRange(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的 score 值的范围来移除成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zRemoveRangeByScore</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().removeRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 和 otherKey 的并集并存储在 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zUnionAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 和 otherKeys 的并集并存储在 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zUnionAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 和 otherKey 的交集并存储在 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zIntersectAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().intersectAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 和 otherKeys 的交集并存储在 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zIntersectAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().intersectAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> options 迭代限制条件, 为 ScanOptions.NONE 则无限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素及分数元组的游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Cursor&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zScan</span><span class="params">(String key, ScanOptions options)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SpringBoot整合Redis</summary>
    
    
    
    <category term="后台成长历程" scheme="https://blog.hiles.cn/categories/%E5%90%8E%E5%8F%B0%E6%88%90%E9%95%BF%E5%8E%86%E7%A8%8B/"/>
    
    
    <category term="java, springboot,redis" scheme="https://blog.hiles.cn/tags/java-springboot-redis/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://blog.hiles.cn/posts/f7ede91d.html"/>
    <id>https://blog.hiles.cn/posts/f7ede91d.html</id>
    <published>2022-09-07T06:39:17.000Z</published>
    <updated>2022-09-07T09:35:31.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java学习！"><a href="#Java学习！" class="headerlink" title="Java学习！"></a>Java学习！</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一行的第三个单词必和文件名一样</span></span><br><span class="line"><span class="comment">// public class 后面代表定义一个类的名称 类是Java当中所有源码的基本组织单位。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">//第二行代表main方法</span></span><br><span class="line">    <span class="comment">//执行程序的起点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//输入输出语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>整数型  byte short int long</p><p>浮点型 float double </p><p>字符型 char </p><p>布尔型 boolean</p><p>P.S float的数据范围比long大</p><p>自动类型转换：可以从小到大转（数据范围）</p><p>强制类型转换：可以大到小，也可以小到大；（一般不推荐使用，可能会发生数据精度缺失）</p><p>byte /shot/char运算时首先提升为int型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">num3</span> <span class="operator">=</span> num1 + num2; <span class="comment">//编译出错！</span></span><br><span class="line">        <span class="comment">//byte + byte --&gt;int + int--&gt;int</span></span><br><span class="line">        <span class="comment">//同理：</span></span><br><span class="line">        <span class="comment">//short + byte --&gt; int + int--&gt;int</span></span><br><span class="line">        <span class="comment">//解决方法：使用强制类型转换;</span></span><br><span class="line">        <span class="comment">//但必须注意保证逻辑上的数据范围！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boolean型不能发生强制类型转换！</p><p>int + double —&gt; double + double —&gt;double</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><h4 id="号"><a href="#号" class="headerlink" title="+号"></a>+号</h4><p>对于字符串来说“+”号代表着字符串连接操作！任何数据类型和字符串进行连接时，结果都会变成字符串；</p><h3 id="自增-自减"><a href="#自增-自减" class="headerlink" title="自增 自减"></a>自增 自减</h3><p>前置：变量先自增（减），后使用；</p><p>后置：变量先使用，后自增（减）；</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个格式:</span></span><br><span class="line"><span class="comment">public static void 方法名 ()&#123;</span></span><br><span class="line"><span class="comment">方法体；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">不能嵌套定义；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Prin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Prin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完整格式：</span></span><br><span class="line"><span class="comment">修饰符 返回值类型 方法名(参数类型 参数名，.....)&#123;</span></span><br><span class="line"><span class="comment">方法体；</span></span><br><span class="line"><span class="comment">return 返回值；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       System.out.println(Add(<span class="number">10</span>,<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>多个方法的名称一样，但是参数列表不同；</p><p>与下列因素有关：</p><p>1.参数个数不同；</p><p>2.参数类型不同；</p><p>3.参数的多类型顺序不同；</p><p>与下列因素无关：</p><p>1.参数名称无关；</p><p>2.返回值类型无关；</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>初始化数组：</p><p>动态(指定长度)：   数据类型[] 数组名称 = new 数据类型[数组长度];</p><p>元素自动初始化为0(整型)/0.0(浮点型)/‘\u0000’(字符型)/false(布尔型)/null(引用类型  )；</p><p>静态(指定内容)：   数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2,};</p><p>静态省略格式：     数据类型[] 数组名称 = { 元素1, 元素2,};.</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>“静态创建对象指的是在栈上创建对象,比如A a;它会在对象的作用域结束后自动销毁. 动态创建对象指的是在堆上创建对象,然后栈上的指针指向创建的对象.比如A *pa = new A();它需要程序员手动delete掉.如果不进行delete操作,只能等到程序结束后,由OS来回收掉.</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> <span class="comment">// 成员变量  定义在方法外，类里面</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 成员方法  成员方法不要写static关键字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125; <span class="comment">//吃</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span> &#123;&#125; <span class="comment">//喝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;&#125; <span class="comment">//玩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;&#125; <span class="comment">//睡</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，一个类不能直接使用，需要根据类创建一个对象，才能使用；</p><p>1.导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名称.类名称</span><br><span class="line">对于和当前类属于同一个包的情况，可以省略；</span><br><span class="line">只有java.lang包下的内容不用导包，其他的包都需要<span class="keyword">import</span>语句</span><br></pre></td></tr></table></figure><p>2.创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名称 对象名 = <span class="keyword">new</span> 类名称();</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p>3.使用</p><p>使用成员变量： 对象名.成员变量</p><p>使用成员方法： 对象名.成员方法</p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><p>可以实现键盘输入数据到程序中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sca</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        <span class="comment">//备注：System.in代表从键盘进行输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">     <span class="comment">//使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">//获取数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next(); <span class="comment">//获取字符串 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   String name;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Showname</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().name = <span class="string">&quot;邱&quot;</span>;</span><br><span class="line">        <span class="comment">//Scanner </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名对象传参</span></span><br><span class="line">        Niin(<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回匿名对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> niout();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Niin</span><span class="params">(Scanner sc)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title function_">Niout</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">        return sc;*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用建议：如果确定有一个对象只需要使用唯一一次，就可以使用匿名对象；</p><p>注意事项：匿名对象只能使用唯一的一次，下次使用不得不再创建一个对象；</p><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ra</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="comment">//获取一个随机的int型数字（范围为int的数据范围）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">        <span class="comment">//获取一个随机的int型数字（范围为参数，左闭右开）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt(<span class="number">3</span>); <span class="comment">//[0,3)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> r.nextInt(<span class="number">3</span>); <span class="comment">//[1,4) </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><p>ArrayList类集合不同于数组，数组长度不可变，ArrayList长度可变；</p><p>&lt; E &gt; 泛型 代表着装在集合中的所有元素都是同一类型；注意 只能是引用类型，不能是基本类型；</p><p>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容；若内容为空，则得到空的中括号；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//ArrayList</span></span><br><span class="line">        <span class="comment">//创建了一个ArrayList集合，集合名称为list，里面装的是String类型数据</span></span><br><span class="line">        <span class="comment">//备注：从JDK1.7+开始，右侧尖括号内部可空，但尖括号仍需要存在！</span></span><br><span class="line">        ArrayList&lt;String&gt; list  =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        常用方法</span></span><br><span class="line"><span class="comment">        public boolean add(E  e); 向集合当中添加元素，参数的类型和泛型一致。返回值代表是否成功；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public E get(int index);  从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public E remove(int index); 从集合当中删除元素，参数是索引编号，返回值就是被删除的元素；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public int size();      获取集合的尺寸长度，返回值为集合中包含的元素个数；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 add</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> list.add(<span class="string">&quot;qiu&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.add(<span class="string">&quot;wu&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;lu&quot;</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">//[qiu, wu, lu]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素 get</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(name); <span class="comment">//wu</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除元素 remove</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">whoremove</span> <span class="operator">=</span> list.remove(<span class="number">1</span>);</span><br><span class="line">        System.out.println(whoremove);  <span class="comment">//wu</span></span><br><span class="line">        System.out.println(list);       <span class="comment">//[qiu, lu]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合长度 size</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的长度是&quot;</span> + size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对于的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本类型      包装类（引用类型，包装类都位于Java.lang包下）</span></span><br><span class="line"><span class="comment">byteByte</span></span><br><span class="line"><span class="comment">shortShort</span></span><br><span class="line"><span class="comment">intInteger</span></span><br><span class="line"><span class="comment">long Long</span></span><br><span class="line"><span class="comment">floatFloat</span></span><br><span class="line"><span class="comment">doubleDouble</span></span><br><span class="line"><span class="comment">charCharacter</span></span><br><span class="line"><span class="comment">booleanBoolean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">        list.add(<span class="number">200</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">//[100, 200]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一号元素是&quot;</span> + num); <span class="comment">//第一号元素是200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类代表字符串；字符串是常量；</p><p>字符串的效果相当于是char[]字符数组，但底层原理是byte[]字节数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span>；<span class="comment">//创建一个空白字符串，不含有任何内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span>[] Array)</span>;<span class="comment">//根据字符数组的内容，来创建对应的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] array = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span>[] array)</span>; <span class="comment">//根据字节数组的内容，来创建对应的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] array1 = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一种直接创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字符串常量池(在堆中)：程序当中直接写上的双引号字符串，就在字符串常量池中；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line">str4 == str2  <span class="comment">//返回值为false</span></span><br><span class="line">str5 == str4<span class="comment">//返回值为true 地址值一样因为字符串为常量具有可共享的属性</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于基本类型来说；==是进行数值比较</span></span><br><span class="line"><span class="comment">    对于引用类型来说；==是进行地址值的比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串内容比较</span></span><br><span class="line"><span class="comment">    public boolean equals(Object obj):参数可以是任何对象，只有参数是一个字符串且内容相同才会返回true</span></span><br><span class="line"><span class="comment">任何对象都可以用object接收</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public boolean equalsIgnoreCase(String str); 忽略大小写进行比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    str4.equals(str2); --&gt;<span class="literal">true</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>.equals(str2); --&gt;<span class="literal">true</span><span class="comment">//推荐 “abc”.equals(str); 若str为null时,上一种方法会报错空指针异常</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*字符串获取方法</span></span><br><span class="line"><span class="comment">public int length(); //获取字符串长度</span></span><br><span class="line"><span class="comment">public String concat(String str);//拼接字符串</span></span><br><span class="line"><span class="comment">public char charAt(int index);//获取指定索引位置的字符</span></span><br><span class="line"><span class="comment">public int indexOf(String str);//查找参数字符串在本字符串出现的首个索引位置，无则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*字符串截取方法</span></span><br><span class="line"><span class="comment">public String substring(int index);//截取从参数位置到最后的字符串</span></span><br><span class="line"><span class="comment">public String substring(int begin,int end);//截取[begin,end)范围的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*字符串转换方法</span></span><br><span class="line"><span class="comment">public char[] toCharArray();//当前字符串拆分成字符数组</span></span><br><span class="line"><span class="comment">public byte[] getBytes();//当前字符串拆分成字节数组</span></span><br><span class="line"><span class="comment">public String replace(CharSequence oldString,CharSequence newString);</span></span><br><span class="line"><span class="comment">将所有出现的老字符串替换成新的字符串，返回替换之后的新字符串；</span></span><br><span class="line"><span class="comment">CharSequence 可以接收字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串截取方法</span></span><br><span class="line"><span class="comment">public String[] split(String regex); //按照参数规则切割字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><h3 id="static静态"><a href="#static静态" class="headerlink" title="static静态"></a>static静态</h3><p>一旦使用static关键字，那么这样的内容不再属于对象自己，而是属于类的，所以凡是本类的对象，都共享同一份； </p><p>一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，属于类；</p><p>如果没有static关键字，那么必须先创建对象，然后通过对象才能使用成员方法；</p><p>对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用；</p><p>P.s 静态不能直接访问非静态；原因：在内存当中先有的静态内容，后有的非静态内容；</p><p>​      静态方法当中不使用this关键字；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String Room;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idCounter</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//每当new一个新对象的时候计数器++</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Staticmethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//首先创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()；</span><br><span class="line">        <span class="comment">//然后才能调用无static关键字的方法</span></span><br><span class="line">        one.method();</span><br><span class="line">        <span class="comment">//静态方法：两者都正确，但推荐使用第二种方法；</span></span><br><span class="line">        one.Staticmethod();</span><br><span class="line">        Student.Staticmethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态代码块：</span></span><br><span class="line"><span class="comment">public class 类名称&#123;</span></span><br><span class="line"><span class="comment">static &#123;</span></span><br><span class="line"><span class="comment">//静态代码块内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">特点：当第一次用到本类时，静态代码块执行唯一的一次；</span></span><br><span class="line"><span class="comment">静态内容总是优先于非静态，所以静态代码块比构造方法先执行；</span></span><br><span class="line"><span class="comment">典型用途：</span></span><br><span class="line"><span class="comment">用来一次性地对静态成员变量进行赋值；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(数组)</span>:将参数数组变成字符串(按照默认格式：[元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3</span>])；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(数组)</span>: 将参数数组升序排序（字符按字典序）；</span><br><span class="line">如果是自定义的类型，那么这个自定义的类需要有Comparable或Comparator接口支持；</span><br></pre></td></tr></table></figure><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>java.util.Math是一个与数学相关的工具类，里面提供了大量静态方法，用来实现数学常见操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">abs</span><span class="params">(<span class="type">double</span> num)</span>:获取绝对值</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> num)</span>:向上取整</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floot</span><span class="params">(<span class="type">double</span> num)</span>:向下取整</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> num)</span>:四舍五入</span><br><span class="line">Math.PI Π的近似值</span><br></pre></td></tr></table></figure><h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><h3 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h3><p>三大特征：封装性，继承性，多态性；</p><p>继承是多态的前提；如果没有继承，就没有多态；</p><p>继承主要解决的问题就是：<strong>共性抽取</strong></p><p>共性存放于父类，也叫基类，超类；</p><p>特殊的存放于子类，也叫派生类；</p><p>继承关系中的特点：</p><p>1.子类可以拥有父类的“内容”；</p><p>2.子类还可以拥有自己的专属内容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在继承的关系中，“子类就是一个父类”；也就是说，子类可以被当成父类看待；</span></span><br><span class="line"><span class="comment">例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义父类格式：</span></span><br><span class="line"><span class="comment">public class 父类名称&#123;</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义子类格式:</span></span><br><span class="line"><span class="comment">public class 子类名称 extends 父类名称&#123;</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</span></span><br><span class="line"><span class="comment">1.直接通过子类对象访问成员变量</span></span><br><span class="line"><span class="comment">(new的时候)等号左边是谁就优先用谁，没有则向上找；</span></span><br><span class="line"><span class="comment">2.间接通过成员方法访问成员变量</span></span><br><span class="line"><span class="comment">方法是哪类的就优先使用哪类的成员变量，无则向上找；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">局部变量：直接写成员变量名</span></span><br><span class="line"><span class="comment">本类的成员变量：  this.成员变量名</span></span><br><span class="line"><span class="comment">父类的成员变量：  super.成员变量名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</span></span><br><span class="line"><span class="comment">创建的对象是谁就优先用谁；无则向上找；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的重写（Override）</span></span><br><span class="line"><span class="comment">概念：在继承关系当中，方法名称一样，参数列表也一样；</span></span><br><span class="line"><span class="comment">方法的覆盖重写特点：创建的是子类对象，则优先使用子类方法；</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">1.必须保证父子类之间的方法名称相同，参数列表也相同；</span></span><br><span class="line"><span class="comment">@Override：写在方法前面用来检测是不是有效的覆盖重写；</span></span><br><span class="line"><span class="comment">这个注解就算不写，只要满足要求，也是正确的方法覆盖重写；</span></span><br><span class="line"><span class="comment">2.子类方法的返回值必须小于等于父类方法的返回值范围；</span></span><br><span class="line"><span class="comment">object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类；</span></span><br><span class="line"><span class="comment">3.子类方法的权限必须大于等于父类方法的权限修饰符；</span></span><br><span class="line"><span class="comment">public &gt; protected &gt; (default) &gt; private</span></span><br><span class="line"><span class="comment">备：(default)不是关键字default，而是什么都不写，留空；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设计原则：</span></span><br><span class="line"><span class="comment">对于已经投入使用的类，尽量不要进行修改；</span></span><br><span class="line"><span class="comment">推荐定义一个新的类，来重复利用其中的共性内容，并添加改动的新内容；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment">1.子类构造方法当中有个隐含的“super()”调用（先构造父类后构造子类）；每当new上一个子类，系统便会new上一个父类；</span></span><br><span class="line"><span class="comment">2.可以通过super关键字来子类构造调用父类重载构造方法；</span></span><br><span class="line"><span class="comment">3.super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造方法中调用多次super构造；</span></span><br><span class="line"><span class="comment">4.子类必须调用父类构造方法，不写系统自动补充super()；写了则用指定的super调用方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字：</span></span><br><span class="line"><span class="comment">1.在子类的成员方法中，访问父类的成员变量；</span></span><br><span class="line"><span class="comment">2.在子类的成员方法中，访问父类的成员方法；</span></span><br><span class="line"><span class="comment">3.在子类的构造方法中，访问父类的构造方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字：</span></span><br><span class="line"><span class="comment">1.在本类的成员方法中，访问本类的成员变量；</span></span><br><span class="line"><span class="comment">2.在本类的成员方法中，访问本类的另一个成员方法；</span></span><br><span class="line"><span class="comment">3.在本类的构造方法中，访问本类的另一个构造方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">java语言是单继承的；</span></span><br><span class="line"><span class="comment">一个类的直接父亲只能有唯一一个；</span></span><br><span class="line"><span class="comment">java可以多级继承；</span></span><br><span class="line"><span class="comment">class A&#123;&#125;;</span></span><br><span class="line"><span class="comment">class B extends A&#123;&#125;;</span></span><br><span class="line"><span class="comment">class c extends B&#123;&#125;;</span></span><br><span class="line"><span class="comment">一个子类只有一个直接父类，但一个父类可以有多个子类；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果父类当中的方法不确定任何进行&#123;&#125;方法体的实现，那么这就应该是一个抽象方法；</span></span><br><span class="line"><span class="comment">抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束；</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类；在class之前加上abstract关键字；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用方法：</span></span><br><span class="line"><span class="comment">1.不能直接创建new抽象类对象；</span></span><br><span class="line"><span class="comment">2.必须要一个子类来继承抽象父类；</span></span><br><span class="line"><span class="comment">3.子类必须覆盖重写父类当中所有的抽象方法；</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号；</span></span><br><span class="line"><span class="comment">4.创建子类对象进行使用；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">抽象方法格式：</span></span><br><span class="line"><span class="comment">public abstract 返回值类型 方法名称(参数列表);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：一个抽象类不一定包含抽象方法；没有抽象方法的抽象类也不能直接new对象；子类也可以是抽象类；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是一种公共的标准规范；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口就是多个类的规范；</span></span><br><span class="line"><span class="comment">接口是一种引用类型，最重要的内容就是其中的：抽象方法；</span></span><br><span class="line"><span class="comment">定义格式：</span></span><br><span class="line"><span class="comment">public interface 接口名称&#123;</span></span><br><span class="line"><span class="comment">//接口内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Java7 ：</span></span><br><span class="line"><span class="comment">接口中可以有：</span></span><br><span class="line"><span class="comment">1.常量</span></span><br><span class="line"><span class="comment">2.抽象方法</span></span><br><span class="line"><span class="comment">3.默认方法（Java8以上）</span></span><br><span class="line"><span class="comment">4.静态方法（Java8以上）</span></span><br><span class="line"><span class="comment">5.私有方法（Java9以上）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接口当中的抽象方法，修饰符必须是两个固定的关键字： public abstract（可以选择性省略）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接口使用步骤：</span></span><br><span class="line"><span class="comment">1.接口不能直接使用，必须有一个“实现类”来“实现”该接口；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class 实现类名称 implements 接口名称 &#123;</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2.接口的实现类必须覆盖重写（实现）接口中的所有的抽象方法；</span></span><br><span class="line"><span class="comment">去掉abstract关键字，加上方法体大括号；</span></span><br><span class="line"><span class="comment">3.创建实现类的对象，进行使用；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">如果实现类并没有覆盖重写接口中的所有的抽象方法，那么那个实现类自己就必须是抽象类；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Java8开始支持默认方法；备注接口当中的默认方法，可以解决接口升级问题；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public default 返回值类型 方法名称(参数列表)&#123;//public 可省略</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意:</span></span><br><span class="line"><span class="comment">1.接口的默认方法，可以通过接口实现类对象，直接调用；</span></span><br><span class="line"><span class="comment">2.接口的默认方法，可以被接口实现类进行覆盖重写；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Java 8开始允许定义静态方法；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static 返回值类型 方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：不能通过接口实现类的对象来调用接口当中的静态方法；</span></span><br><span class="line"><span class="comment">正确用法：直接通过接口名称直接调用静态方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Java 9接口中允许定义私有方法；</span></span><br><span class="line"><span class="comment">1.普通私有方法，解决多个默认方法之间重复代码问题；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">private 返回值类型 方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2.静态私有方法，解决多个静态方法之间重复代码问题；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">private static 返回值类型 方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接口中可以定义“成员变量” 但是必须使用public static final 这三个关键字进行修饰</span></span><br><span class="line"><span class="comment">从效果上看，这其实是接口的【常量】；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static final 数据类型 常量名称 = 数据值；</span></span><br><span class="line"><span class="comment">一旦使用final关键字进行修饰，说明不可变；</span></span><br><span class="line"><span class="comment">public static final 可以省略，但任然存在；</span></span><br><span class="line"><span class="comment">接口当中的常量，必须进行赋值，不能不赋值；</span></span><br><span class="line"><span class="comment">接口当中的常量的名称，使用完全大写的字母，用下划线进行分隔（推荐命名规则）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.接口不能有静态代码块或者构造方法；</span></span><br><span class="line"><span class="comment">2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class 实现类名称 implements 接口1,接口2&#123;</span></span><br><span class="line"><span class="comment">//覆盖重写所有的抽象方法</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次就好；</span></span><br><span class="line"><span class="comment">4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类；</span></span><br><span class="line"><span class="comment">5.如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</span></span><br><span class="line"><span class="comment">6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先使用父类当中的方法；</span></span><br><span class="line"><span class="comment">7.类与接口之间是多实现的，一个类可以实现多个接口；</span></span><br><span class="line"><span class="comment">8.接口与接口之间是多继承的；</span></span><br><span class="line"><span class="comment">8.1.多个父接口当中的抽象方法如果重复，没关系；</span></span><br><span class="line"><span class="comment">8.2.多个父接口当中的默认方法不能重复，需要在子接口中进行默认方法覆盖重写（default关键字不可省略）；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个对象拥有多种形态，这也就是对象的多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码当中体现多态性，父类引用指向子类对象；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">父类名称 对象名 = new 子类名称()；</span></span><br><span class="line"><span class="comment">或者</span></span><br><span class="line"><span class="comment">接口名称 对象名 = new 实现类名称();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员方法:</span></span><br><span class="line"><span class="comment">口诀：编译看左边，运行看右边；</span></span><br><span class="line"><span class="comment">成员变量：</span></span><br><span class="line"><span class="comment">口诀：编译看左边，运行看左边；  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对象的向上转型，其实就是多态的写法；</span></span><br><span class="line"><span class="comment">格式：父类名称 对象名 = new 子类名称；</span></span><br><span class="line"><span class="comment">含义：右侧创建了一个子类对象，把他当成父类来看待使用；</span></span><br><span class="line"><span class="comment">注意事项：向上转型一定是安全的；从小范围转向大范围；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对象一旦向上转型为父类，那么就无法调用子类原本特有的内容；</span></span><br><span class="line"><span class="comment">解决方案：</span></span><br><span class="line"><span class="comment">对象的向下转型：其实是一个还原的动作：</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">子类名称 对象名 = (子类名称)父类对象；</span></span><br><span class="line"><span class="comment">含义：将父类对象，还原成为本来的子类对象；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何才能知道一个父类引用对象，本来是什么子类？</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">对象 instanceof 类名称；</span></span><br><span class="line"><span class="comment">这将会得到一个Boolean值，也就是判断前面的对象是否能够成为后面类型的实例；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第十天"><a href="#第十天" class="headerlink" title="第十天"></a>第十天</h2><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">final关键字代表最终，不可改变的</span></span><br><span class="line"><span class="comment">常见用法：</span></span><br><span class="line"><span class="comment">1.可以修饰一个类</span></span><br><span class="line"><span class="comment">2.可以用来修饰一个方法</span></span><br><span class="line"><span class="comment">3.修饰一个局部变量</span></span><br><span class="line"><span class="comment">4.修饰一个成员变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当final用来修饰一个类的时候</span></span><br><span class="line"><span class="comment">格式:</span></span><br><span class="line"><span class="comment">public final class 类名称&#123;</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">含义：当前这个类不能有任何子类；且其中的所有成员方法都无法进行覆盖重写；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当final用来修饰一个方法的时候，这个方法就是最终方法，不能被覆盖重写；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">修饰符 final 返回值类型 方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">对于类，方法来说，abstract和final不能同时使用；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一旦用final修饰局部变量，就一次赋值，终身不变；</span></span><br><span class="line"><span class="comment">对于基本类型来说，变量当中的数据不可变；</span></span><br><span class="line"><span class="comment">对于引用类型来说，变量当中的地址值不变；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">final修饰成员变量</span></span><br><span class="line"><span class="comment">1.由于成员变量具有默认值，一旦使用final修饰后必须手动赋值；</span></span><br><span class="line"><span class="comment">2.对于final的成员变量，要么直接赋值，要么通过构造方法赋值；</span></span><br><span class="line"><span class="comment">3.必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java 中有四种权限修饰符：</span></span><br><span class="line"><span class="comment">public &gt; protected &gt; (default) &gt; private</span></span><br><span class="line"><span class="comment">同一个类yes yesyesyes</span></span><br><span class="line"><span class="comment">同一个包yes      yesyesno</span></span><br><span class="line"><span class="comment">不同包子类          yesyes    no    no</span></span><br><span class="line"><span class="comment">不同包非子类   yesno     nono</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：(default)并不是关键字default而是根本不写；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第十一天"><a href="#第十一天" class="headerlink" title="第十一天"></a>第十一天</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java.lang.Object类是Java语言中的根类，即所有类的父类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String toString(); 返回该对象的字符串表示；(可以获取对象的地址值)</span></span><br><span class="line"><span class="comment">但打印对象的地址值是没有意义的，需要覆盖重写toString方法；</span></span><br><span class="line"><span class="comment">直接打印对象名，其实就是调用对象的toString方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">boolean equals(Object obj)； 指示其他某个对象是否与此对象&quot;相等&quot;；</span></span><br><span class="line"><span class="comment">Object类equals方法的源码:</span></span><br><span class="line"><span class="comment">public boolean equals(Object obj)&#123;</span></span><br><span class="line"><span class="comment">return (this == obj);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">方法体：</span></span><br><span class="line"><span class="comment"> == 比较运算符:</span></span><br><span class="line"><span class="comment"> 基本数据类型 比较值；</span></span><br><span class="line"><span class="comment"> 引用数据类型 比较两个对象的地址值;</span></span><br><span class="line"><span class="comment">所以我们应该覆盖重写equals方法，比较两个对象的属性值；</span></span><br><span class="line"><span class="comment">问题:</span></span><br><span class="line"><span class="comment">隐含着一个多态；</span></span><br><span class="line"><span class="comment">多态弊端：无法使用子类的特有内容；</span></span><br><span class="line"><span class="comment">解决：使用向下转型；把Object类型强制转换为当前类型；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jdk7:</span></span><br><span class="line"><span class="comment">public static boolean equals(Object a, Object b)&#123;</span></span><br><span class="line"><span class="comment">retrun (a == b)||(a != null &amp;&amp; a.equals(b));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">对象为空时，不能调用Object的equals方法，这容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题；</span></span><br><span class="line"><span class="comment">*/</span>  </span><br></pre></td></tr></table></figure><h2 id="第十一天-1"><a href="#第十一天-1" class="headerlink" title="第十一天"></a>第十一天</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个事物的内部包含着另一个事物，那么就是一个类的内部包含另一个类；</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">1.成员内部类</span></span><br><span class="line"><span class="comment">2.局部内部类(包括匿名内部类)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员内部类：</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">修饰符 class 外部类名称&#123;</span></span><br><span class="line"><span class="comment">修饰符 class 内部类名称&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：内用外，随意访问；外用内，一定需要借助内部类对象；</span></span><br><span class="line"><span class="comment">———————-----------------—————————————————————</span></span><br><span class="line"><span class="comment">使用成员内部类方法：</span></span><br><span class="line"><span class="comment">1.间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类方法；</span></span><br><span class="line"><span class="comment">2.直接方式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</span></span><br><span class="line"><span class="comment">如果出现了重名现象： 外部类.this.外部类成员变量名；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">局部内部类：定义于一个方法的内部；</span></span><br><span class="line"><span class="comment">“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不可使用了；</span></span><br><span class="line"><span class="comment">定义格式:</span></span><br><span class="line"><span class="comment">修饰符 class 外部类名称&#123;</span></span><br><span class="line"><span class="comment">修饰符 返回值类型 外部类方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">class 局部内部类名称&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的；</span></span><br><span class="line"><span class="comment">原因：</span></span><br><span class="line"><span class="comment">1.new出来的对象在堆内存中；</span></span><br><span class="line"><span class="comment">2.局部变量跟着方法在栈内存中；</span></span><br><span class="line"><span class="comment">3.方法运行完之后会立即出栈，局部变量消失；</span></span><br><span class="line"><span class="comment">4.但是new出来的对象会在堆中持续存在，直到垃圾回收消失； </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名内部类：</span></span><br><span class="line"><span class="comment">如果接口的实现类（或者是父类的子类）只需要使用唯一的一次</span></span><br><span class="line"><span class="comment">那么这种情况下就可以省略该类的定义，而改为使用【匿名内部类】</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">接口名称 对象名 = new 接口名称()&#123;</span></span><br><span class="line"><span class="comment">//覆盖重写所有的抽象方法；</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">P.s:匿名内部类是省略了【实现类/子类名称】，但匿名对象省略了【对象名】；</span></span><br><span class="line"><span class="comment">匿名内部类和匿名对象不是同一回事；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">权限修饰符：</span></span><br><span class="line"><span class="comment">定义一个类的时候：</span></span><br><span class="line"><span class="comment">1.外部类：public / (default)</span></span><br><span class="line"><span class="comment">2.成员内部类： public / protected / (default) / private</span></span><br><span class="line"><span class="comment">3.局部内部类：什么都不能写； 不同于(default)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第十二天-日期时间类"><a href="#第十二天-日期时间类" class="headerlink" title="第十二天 日期时间类"></a>第十二天 日期时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Date:表示日期和时间的类；</span></span><br><span class="line"><span class="comment">类Date表示特定的瞬间，精确到毫秒;</span></span><br><span class="line"><span class="comment">时间原点（0毫秒）:1970.1.1 00:00:00(英国格林威治)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">无参：</span></span><br><span class="line"><span class="comment">Date();获取当前的系统的日期和时间；</span></span><br><span class="line"><span class="comment">带参:</span></span><br><span class="line"><span class="comment">Date(long date);传递毫秒值，把毫秒转换为Date日期;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员方法:</span></span><br><span class="line"><span class="comment">long getTime()返回自时间原点以来此Date对象表示的毫秒值；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="DateFormat类-抽象类"><a href="#DateFormat类-抽象类" class="headerlink" title="DateFormat类(抽象类)"></a>DateFormat类(抽象类)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">日期/时间格式化子类的抽象类；</span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">    1.格式化（日期-&gt;文本）</span></span><br><span class="line"><span class="comment">    2.解析（文本-&gt;日期）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment"> 成员方法：</span></span><br><span class="line"><span class="comment"> String format(Date date)按照指定的模式，把Date日期格式化为符合模式的字符串；</span></span><br><span class="line"><span class="comment"> Date parse(String source)把符合模式的字符串，解析为Date日期；</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">SimpleDateFormat类继承DateFormat类</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">SimpleDateFormat(String pattern)用给定的模式和默认语言环境日期格式构造SimpleDateFormat。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">String patten ：传递指定的模式；</span></span><br><span class="line"><span class="comment">模式：区分大小写</span></span><br><span class="line"><span class="comment">y - 年写对应的模式，会把模式替换成对应的日期和时间；</span></span><br><span class="line"><span class="comment">M - 月</span></span><br><span class="line"><span class="comment">d - 日</span></span><br><span class="line"><span class="comment">H - 时</span></span><br><span class="line"><span class="comment">m - 分</span></span><br><span class="line"><span class="comment">s - 秒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习题</span></span><br><span class="line"><span class="comment">//计算出一个人已经出生了多少天？</span></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入出生日期: 格式 YYYY-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birthDay</span> <span class="operator">=</span> sdf.parse(birth);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">today</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间对应毫秒值：&quot;</span> + today.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;出生日期对应毫秒值：&quot;</span> + birthDay.getTime());</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> today.getTime()-birthDay.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;时间差为：&quot;</span> + time);</span><br><span class="line">        <span class="type">long</span> <span class="variable">day</span> <span class="operator">=</span> time/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;相差天数为：&quot;</span> + day);</span><br><span class="line">        <span class="type">long</span> <span class="variable">year</span> <span class="operator">=</span> day/<span class="number">365</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经&quot;</span> + year + <span class="string">&quot;岁啦！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十三天"><a href="#第十三天" class="headerlink" title="第十三天"></a>第十三天</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常量：</span></span><br><span class="line"><span class="comment">public static final int SPRING = 1;</span></span><br><span class="line"><span class="comment">缺点：类型不安全，可以当做整数参与计算，并且输出的意义不明确！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">枚举类</span></span><br><span class="line"><span class="comment">一种特殊的类，可以清晰的枚举出每一项数据，可以避免错误的运算！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">规范：</span></span><br><span class="line"><span class="comment">1. 枚举类是特殊的类，通过enum关键字进行定义；</span></span><br><span class="line"><span class="comment">2. 枚举类可以定义成员变量、成员方法、构造方法，也可以实现接口；</span></span><br><span class="line"><span class="comment">3. 枚举类默认继承于java.lang.Enum类，并且不能继承于其他父类；</span></span><br><span class="line"><span class="comment">4. 非抽象的枚举类默认使用final修饰，所以枚举类不能派生出子类；</span></span><br><span class="line"><span class="comment">5. 枚举类的构造方法默认使用private修饰，并且只能使用private修饰；</span></span><br><span class="line"><span class="comment">6. 枚举类的所有实例，必须在类中第一行显示列出，它们默认是public static final的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现接口：</span></span><br><span class="line"><span class="comment">可以直接在枚举实例上进行方法重写；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在枚举类中定义抽象方法，需在实例内重写抽象方法；</span></span><br><span class="line"><span class="comment">一般来说enum类为final修饰，一旦定义了抽象方法后被abstra修饰；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="topview面试问题总结"><a href="#topview面试问题总结" class="headerlink" title="topview面试问题总结"></a>topview面试问题总结</h3><h4 id="1-面向接口编程"><a href="#1-面向接口编程" class="headerlink" title="1.面向接口编程"></a>1.面向接口编程</h4><p>疑问：为什么有的地方必须使用接口而不是抽象类，而在另一些地方，又必须使用抽象类而不是接口呢？</p><p>原则：行为模型应该总是通过接口而不是抽象类定义；</p><p>根本的原因在于使用抽象类不仅意味着定义特定的行为，而且意味着定义实现的模式。也就是说，应该定义一个事物如何获得行为的模型，而不仅仅是声明事物具有某一个行为。</p><p>interface关键字用来声明一个接口，它可以产生一个完全抽象的类，并且不提供任何具体实现。interface的特性整理如下：</p><ol><li><p>接口中的方法可以有参数列表和返回类型，但不能有任何方法体。</p></li><li><p>接口中可以包含字段，但是会被隐式的声明为static和final。</p></li><li><p>接口中的字段只是被存储在该接口的静态存储区域内，而不属于该接口。</p></li><li><p>接口中的方法可以被声明为public或不声明，但结果都会按照public类型处理。</p></li><li><p>当实现一个接口时，需要将被定义的方法声明为public类型的，否则为默认访问类型，Java编译器不允许这种情况。</p></li><li><p>如果没有实现接口中所有方法，那么创建的仍然是一个接口。</p></li><li>扩展一个接口来生成新的接口应使用关键字extends，实现一个接口使用implements。</li></ol><p>interface在某些地方和abstract有相似的地方，但是采用哪种方式来声明类主要参照以下两点：</p><ol><li><p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。</p></li><li><p>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</p></li></ol><p>接口应有两类：</p><p>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；</p><p>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</p><h4 id="Linkedlist的底层实现逻辑"><a href="#Linkedlist的底层实现逻辑" class="headerlink" title="Linkedlist的底层实现逻辑"></a>Linkedlist的底层实现逻辑</h4><p><strong>ArrayList和LinkedList的区别如下：</strong></p><ol><li>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。</li><li>对于随机访问，ArrayList优于LinkedList，ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问。而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)</li><li>对于插入和删除操作，LinkedList优于ArrayList，因为当元素被添加到LinkedList任意位置的时候，不需要像ArrayList那样重新计算大小或者是更新索引。</li><li>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li></ol><h2 id="第十五天"><a href="#第十五天" class="headerlink" title="第十五天"></a>第十五天</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p>类型确定，长度固定，不适合进行增删操作</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>大小不固定，类型也不固定，适合进行元素的增删操作</p><p>不支持基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可变参数:</span></span><br><span class="line"><span class="comment">在形参中可以接受多个数据 格式： 数据类型...参数名称</span></span><br><span class="line"><span class="comment">可变参数在方法内部其实是一个数组</span></span><br><span class="line"><span class="comment"> 每个方法只能定义一个可变参数</span></span><br><span class="line"><span class="comment"> 一般将可变参数放在参数列表的最后面；</span></span><br><span class="line"><span class="comment">一.单列集合 Collection(集合)(存储元素对象的地址值)</span></span><br><span class="line"><span class="comment">提供的Api：</span></span><br><span class="line"><span class="comment">list.add();添加成功返回true</span></span><br><span class="line"><span class="comment">    list.clear();</span></span><br><span class="line"><span class="comment">    list.isEmpty(); 为空返回true</span></span><br><span class="line"><span class="comment">    list.size();返回集合大小</span></span><br><span class="line"><span class="comment">    list.contains();含有该元素返回true</span></span><br><span class="line"><span class="comment">    list.remove();成功返回true，只会删前面第一个</span></span><br><span class="line"><span class="comment">    list.toArray();默认转成Object[]</span></span><br><span class="line"><span class="comment">    list.addAll();将括号内的集合添加到list</span></span><br><span class="line"><span class="comment">遍历方式：</span></span><br><span class="line"><span class="comment">迭代器：list.iterator()获取迭代器(默认索引位置为0)</span></span><br><span class="line"><span class="comment">方法：boolean hasNext()判断当前位置是否有元素</span></span><br><span class="line"><span class="comment"> E next() 返回当前位置元素，同时将迭代器对象移向下一个位置</span></span><br><span class="line"><span class="comment">foreach：可以遍历集合与数组(必须实现Iterable接口)，无法修改值</span></span><br><span class="line"><span class="comment">Lambert：list.forEach(new Consumer&lt;string&gt;)&#123;重写accept方法&#125;</span></span><br><span class="line"><span class="comment">P.s:</span></span><br><span class="line"><span class="comment">并发修改问题：</span></span><br><span class="line"><span class="comment">当你使用迭代器且使用集合自身remove方法删除元素的时候，会导致删完索引位置的元素后，后面的元素会前移，导致忽略一个元素，此时会抛出异常ConcurrentModificationError;推荐使用迭代器的方法remove；</span></span><br><span class="line"><span class="comment">foreach不能实现并发修改；有上述bug，但无法解决；</span></span><br><span class="line"><span class="comment">for:从末尾开始删除即可；从头开始的话，每当删除一个元素，索引后移（i--）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.list(有序，可重复，有索引)</span></span><br><span class="line"><span class="comment">void add(int index,E e) 指定位置插入元素</span></span><br><span class="line"><span class="comment">E remove(int index)删除索引元素并返回</span></span><br><span class="line"><span class="comment">E set(int index,E e)修改索引元素，并返回修改前的元素</span></span><br><span class="line"><span class="comment">E get(int index)返回索引元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​1.ArrayList</span></span><br><span class="line"><span class="comment">底层原理：</span></span><br><span class="line"><span class="comment">1.第一次创建并添加第一个元素的时候，创建一个长度为10的泛型数组</span></span><br><span class="line"><span class="comment">2.每加一个元素，size++</span></span><br><span class="line"><span class="comment">3.当size要超过当前容量，进行扩容，每次扩容1.5倍；（新建数组）</span></span><br><span class="line"><span class="comment">​2.Linkedlist（点餐可以用linkedlist实现队列）</span></span><br><span class="line"><span class="comment">可以实现栈与队列</span></span><br><span class="line"><span class="comment">特有功能API：</span></span><br><span class="line"><span class="comment">void addFirst(E e)在列表开头插入元素   -&gt;push()</span></span><br><span class="line"><span class="comment">void addLast(E e)在列表末尾追加元素-&gt;offerLast</span></span><br><span class="line"><span class="comment">E getFirst(E e)返回列表第一个元素</span></span><br><span class="line"><span class="comment">E getLast(E e)返回列表第最后一个元素</span></span><br><span class="line"><span class="comment">E removeFirst(E e)删除并返回列表第一个元素-&gt;pop()</span></span><br><span class="line"><span class="comment">E removeLast(E e)删除并返回列表最后一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​2.set(无序（非随机无序），不重复，无索引)</span></span><br><span class="line"><span class="comment">如果希望Set集合认为两个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法；</span></span><br><span class="line"><span class="comment">先判断哈希值，后判断equals；                     </span></span><br><span class="line"><span class="comment">​1.HashSets</span></span><br><span class="line"><span class="comment">底层原理：采用哈希表（一种对于增删改查数据性能较好的结构）jdk8之前底层为数组加链表，之后为数组加链表加红黑树；哈希值：根据对象的地址，按照某种规则算出来的int类型数值（可以通过Hashcode()方法获取）</span></span><br><span class="line"><span class="comment">哈希算法：根据元素哈希值跟数组的长度求余计算出应存入的位置；</span></span><br><span class="line"><span class="comment">红黑树的作用：当数组某个位置下的链表节点过多（超过8个），会影响性能，故采用红黑树进行优化；</span></span><br><span class="line"><span class="comment">​1.LinkedHashSet(有序，不重复，无索引)</span></span><br><span class="line"><span class="comment">底层数据结构仍为哈希表，只是每个元素又额外多了一个双链表的机制记录存储的顺序；</span></span><br><span class="line"><span class="comment">​2.TreeSet(按照默认大小升序，不重复，无索引)</span></span><br><span class="line"><span class="comment">底层：基于红黑树实现排序，增删改查性能都较好；一定是有序的，可以指定排序规则；</span></span><br><span class="line"><span class="comment">自定义的类实现comparable接口，重写compareTo方法；或者用Treeset构造器的时候，实现comparable接口的比较器（优先使用）； </span></span><br><span class="line"><span class="comment">返回值规则：第一个元素大于第二个元素返回正整数，小于返回负整数，等于则返回零；相等时会去重；</span></span><br><span class="line"><span class="comment">比较浮点类型时，可以调用Double.compare()方法比较，以避免出现-0.5，0.5强转精度损失，进而被认为相等的情况；</span></span><br><span class="line"><span class="comment">二.双列集合 Map(由键决定)</span></span><br><span class="line"><span class="comment">特点</span></span><br><span class="line"><span class="comment">    无序，不重复，无索引，值不做要求</span></span><br><span class="line"><span class="comment">    后面重复的键对应的值会覆盖前面重复键的值</span></span><br><span class="line"><span class="comment">    键值对可以为null</span></span><br><span class="line"><span class="comment">元素格式：key==value（键值对元素）</span></span><br><span class="line"><span class="comment">如在购物车中，可以把商品对象看成键，购买数量看成值；</span></span><br><span class="line"><span class="comment">Api：</span></span><br><span class="line"><span class="comment">V put(k,v);添加元素</span></span><br><span class="line"><span class="comment">V remove(E k);根据键删除元素</span></span><br><span class="line"><span class="comment">void clear();移除所有键值对</span></span><br><span class="line"><span class="comment">boolean containKey(E k);判断是否含有指定的键</span></span><br><span class="line"><span class="comment">boolean containValue(E v);判断是否含有指定的值</span></span><br><span class="line"><span class="comment">boolean inEmpty();判断集合是否为空</span></span><br><span class="line"><span class="comment">int size();键值对的个数</span></span><br><span class="line"><span class="comment">Set&lt;K&gt; keySet();获取全部键的集合(键不可重复所以用Set接收)</span></span><br><span class="line"><span class="comment">Collection&lt;V&gt; values();获取全部值的集合(值可重复所以用Collection接收)</span></span><br><span class="line"><span class="comment">map1.putAll(map2);将map2的元素添加到map1；</span></span><br><span class="line"><span class="comment">遍历方式：</span></span><br><span class="line"><span class="comment">1.键找值</span></span><br><span class="line"><span class="comment">先拿到集合的全部键（keySet()），然后使用get()方法</span></span><br><span class="line"><span class="comment">2.键值对</span></span><br><span class="line"><span class="comment">Set&lt;Map,Entry&lt;String,Integer&gt;&gt; entries = map.entrySet(); Enrty是一个接口;</span></span><br><span class="line"><span class="comment">先调用entrySet()方法获取所有键值对对象的集合，将每一个键值对封装成一个实例对象，再通过getKey(),getValue()获取键值对；</span></span><br><span class="line"><span class="comment">3.lambda表达式</span></span><br><span class="line"><span class="comment">default void forEach(BiConsumer&lt;k,v&gt; action);</span></span><br><span class="line"><span class="comment">map.forEach(k,v)-&gt;&#123;System.out.println(k + &quot;-&gt;&quot; + v)&#125;</span></span><br><span class="line"><span class="comment">实现类：</span></span><br><span class="line"><span class="comment">1.HashMap(无序，不重复，无索引，值不做要求)</span></span><br><span class="line"><span class="comment"> 底层实现与Hashset相同；HashSet构造方法是调用的HashMap</span></span><br><span class="line"><span class="comment"> 依赖hashCode和equals方法来保证键的唯一；</span></span><br><span class="line"><span class="comment">1.LinkedHashMap(有序，不重复，无索引，值不做要求)</span></span><br><span class="line"><span class="comment">2.HashTable</span></span><br><span class="line"><span class="comment">1.Properties</span></span><br><span class="line"><span class="comment">3.TreeMap(排序（只能对键排序），不重复（只要大小规则一样则判定为重复），无索引，值不做要求)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>精心选择的数据结构可以带来更高的运行或者存储效率</p><p>抽象数据类型（ADT）：一个数学模型以及定义在这模型上的一系列操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈</span></span><br><span class="line"><span class="comment">~后进先出，先进后出(进入称压栈/进栈，离开称出栈/弹栈)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">队列</span></span><br><span class="line"><span class="comment">~后进后出，先进先出(进入称入队，离开称出队)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数组（查询快，增删慢）</span></span><br><span class="line"><span class="comment">~查询速度快：查询数据通过地址值和索引定位，查询任意数据耗时相同（元素在内存中是连续存储的）</span></span><br><span class="line"><span class="comment">~删除效率低：要将原始数据删除，同时后面每个数据前移</span></span><br><span class="line"><span class="comment">~添加效率极低：添加位置后的每个数据后移，再添加元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表</span></span><br><span class="line"><span class="comment">~查询速度慢：无论查询哪个数据都要通过头节点开始找（元素在内存中不是连续存储的）</span></span><br><span class="line"><span class="comment">~增删效率相对快：只有再增删的时候要快，因为首先要找到增删的位置</span></span><br><span class="line"><span class="comment">~双链表：增删首尾位置的元素极快</span></span><br><span class="line"><span class="comment">（单链表还需要遍历到尾节点进行增加数据，双链表之间在头指针之前插入数据即可）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二叉树</span></span><br><span class="line"><span class="comment">~一个节点包括父节点地址，左右节点地址，及数据域；</span></span><br><span class="line"><span class="comment">~只能有一个根节点，每个节点最多两个直接子节点</span></span><br><span class="line"><span class="comment">~节点的度：节点拥有的子树的个数，二叉树的度不大于2，叶节点度为零的节点，也称之为终端节点；</span></span><br><span class="line"><span class="comment">~叶节点的高度为1，叶子节点的父节点高度为2，根节点的高度最高</span></span><br><span class="line"><span class="comment">~层：根节点为第一层</span></span><br><span class="line"><span class="comment">~兄弟节点：拥有共同父节点的节点互称兄弟节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二叉查找树</span></span><br><span class="line"><span class="comment">~左子树的所有节点值都小于根节点值，右子树反之</span></span><br><span class="line"><span class="comment">目的：提高检索数据的效率</span></span><br><span class="line"><span class="comment">~存入规则：</span></span><br><span class="line"><span class="comment">小的存左边</span></span><br><span class="line"><span class="comment">大的存右边</span></span><br><span class="line"><span class="comment">一样的不存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">平衡二叉树</span></span><br><span class="line"><span class="comment">~二叉查找树可能会存在“瘸子问题” -&gt;变成单链表</span></span><br><span class="line"><span class="comment">~在满足查找二叉树的大小规则下，让树尽可能层数小</span></span><br><span class="line"><span class="comment">~要求：任意节点左右子树高度差不超过1，任意节点左右子树为平衡二叉树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">红黑树（平衡二叉B树）</span></span><br><span class="line"><span class="comment">~通过红黑规则自平衡</span></span><br><span class="line"><span class="comment">根节点必须是黑色</span></span><br><span class="line"><span class="comment">如果一个节点没有子节点，则该节点相应的指针属性为Nil，这些Nil视为叶节点，叶节点为黑色；</span></span><br><span class="line"><span class="comment">如果某一个节点为红色，那么它的子节点必须是黑色</span></span><br><span class="line"><span class="comment">对于每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</span></span><br><span class="line"><span class="comment">~添加节点红黑都可，但默认推荐红色（效率高）；添加相同个数的元素，默认红，调整次数少；</span></span><br><span class="line"><span class="comment">~增删改查的性能好</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="集合工具类"><a href="#集合工具类" class="headerlink" title="集合工具类"></a>集合工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections类</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">()</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">()</span>打乱list集合的顺序（采用随机数）</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list,Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure><h2 id="第十六天"><a href="#第十六天" class="headerlink" title="第十六天"></a>第十六天</h2><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>集合的数据项在创建的时候提供，并且在整个生命周期都不可改变；</p><p>当集合对象被不可信的库调用时，不可变形式是安全的；</p><p>在List,Set,Map接口当中，都存在of方法，可以创建一个不可变的集合；</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>作用：简化匿名内部类的代码写法（只能简化函数式接口的匿名内部类的写法形式）</p><p>函数式接口：首先必须是接口，其次接口中有且仅有一个抽象方法的形式；通常会在接口上加上@FunctionalInterface注解，标记该接口必须式满足函数式接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">省略写法：</span><br><span class="line">    参数类型可以不写</span><br><span class="line">    如果只有一个参数，参数类型可以省略，同时（）也可以省略</span><br><span class="line">    如果表达式的方法体代码只有一行，可以省略大括号不写，同时要省略分号；若此时这行代码是<span class="keyword">return</span>语句，必须省略<span class="keyword">return</span>不写，同时也必须省略;分号不写</span><br></pre></td></tr></table></figure><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p>得益于Lambda所带来的函数式编程，引入的全新概念 =》流水线</p><p>目的：用于简化集合和数组操作的API</p><p>使用步骤：</p><p>1.先得到集合或数组的Stream流；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合获取当前对象的Stream流</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//数组获取当前对象的Stream流</span></span><br><span class="line"><span class="comment">//(Arrays工具类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span></span><br><span class="line"><span class="comment">//stream类静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span></span><br></pre></td></tr></table></figure><p>2.把元素放上去；</p><p>3.用stream流的简化API操作元素；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于对流中的数据进行过滤。</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br><span class="line"><span class="comment">//获取前几个元素</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> size)</span></span><br><span class="line"><span class="comment">//跳过前几个元素</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line"><span class="comment">//去除流中重复的元素(依赖Hashcode,equals方法)</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span></span><br><span class="line"><span class="comment">//合并a,b两个流为一个流</span></span><br><span class="line"><span class="keyword">static</span> Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream a,Stream b)</span> </span><br><span class="line"><span class="comment">//获取元素个数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line"><span class="comment">//Map加工方法</span></span><br><span class="line"><span class="comment">//可以给流中的每一个元素进行加工，如在集合元素前加一个字符串 T-&gt;原材料 R-&gt;加工后的</span></span><br><span class="line">stream&lt;T&gt; <span class="title function_">map</span><span class="params">(Function&lt;T,R&gt; function)</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">apply</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;标记&quot;</span> + t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取最大值</span></span><br><span class="line">Opentional&lt;T&gt; <span class="title function_">max</span><span class="params">(comparetor c)</span>;</span><br><span class="line"><span class="comment">/*Demo</span></span><br><span class="line"><span class="comment">需求： 某个公司的开发部门, 分为开发一部和二部， 现在需要进行年中数据结算。</span></span><br><span class="line"><span class="comment">分析</span></span><br><span class="line"><span class="comment">1.员工信息至少包含了（ 名称、性别、工资、奖金、处罚记录）</span></span><br><span class="line"><span class="comment">2.开发一部有4个员工、开发二部有5名员工</span></span><br><span class="line"><span class="comment">3.分别筛选出2个部门的最高工资的员工信息, 封装装成优秀员工对象Topperformer</span></span><br><span class="line"><span class="comment">4.分别统计出2个部门的平均月收入要求去掉最高和最低工资。</span></span><br><span class="line"><span class="comment">5.统计2个开发部门整体的平均工资,去掉最低和最高工资的平均值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*收集Stream流</span></span><br><span class="line"><span class="comment">将流操作后的结果数据传回集合或数组中去；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">R <span class="title function_">collect</span><span class="params">(Collector collector)</span> <span class="comment">//开始收集Stream流。指定收集器</span></span><br><span class="line"><span class="comment">//Collectors工具类提供了具体的收集方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector <span class="title function_">toList</span><span class="params">()</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector <span class="title function_">toSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector <span class="title function_">toMap</span><span class="params">(Function keyMapper,Function valueMapper)</span> </span><br><span class="line"><span class="comment">//直接收集成集合 list()方法但返回的是不可变集合</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>程序在“编译”或者“执行”的过程中可能出现的问题，注意：语法错误不算在异常体系中；</p><p>异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止；</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center"></th><th style="text-align:center">Throwable</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td></td><td style="text-align:center">Error</td><td style="text-align:center"></td><td style="text-align:center">Exception</td><td style="text-align:center"></td></tr><tr><td></td><td style="text-align:center"></td><td style="text-align:center">RuntimeException</td><td style="text-align:center"></td><td style="text-align:center">除RuntimeException之外的所有异常</td></tr><tr><td></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><p>Error:系统级别问题，JVM退出等，代码无法控制</p><p>Exception：称为异常类，它表示程序本身可以处理的问题</p><p>RuntimeException及其子类：运行时异常，编译阶段不会报错;</p><p>  除RuntimeException之外的所有异常 :编译时异常，编译期必须处理的，否则程序不能通过编译；</p><p><strong>默认处理流程</strong>：</p><p>​    1.默认会在出现异常的代码那里自动的创建一个异常对象： ArithmeticException 。<br>​    2.异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM 虚拟机。<br>​    3.虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。<br>​    4.直接从当前执行的异常点干掉当前程序。<br>​    5.后续代码没有机会执行了， 因为程序已经死亡。</p><p><strong>异常处理机制</strong>：</p><p><strong>处理方式1：throws 异常1，异常2…</strong></p><p>用在方法上，可以将方法内部出现的异 常抛出去给本方法的调用者处理；规范做法：直接抛出Exception；</p><p><strong>处理方式2：try…catch…</strong></p><p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行；建议直接catch(Exception)异常，然后打印异常栈信息；</p><p><strong>处理方式3 前两者结合</strong>（推荐）</p><p>方法直接将异常通过throws抛出给调用者，调用者收到异常后直接捕获处理；  </p><p> <strong>自定义异常</strong></p><p>1.自定义编译时异常<br>· 定义一个异帛类继承Exception.<br>· 重写构造器。<br>· 在出现异常的地方用throw new 自定义对象抛出。</p><p>作用：编译时异常是编译阶段就报错，提醒更加强烈！</p><p>throw ：在方法内部直接创建一个异常对象，并从此点抛出</p><p>throws：用在方法声明上的，抛出方法内部的异常；</p><p>2.自定义运行时异常<br>· 定义一个异帛类继承RuntimeException.<br>· 重写构造器。<br>· 在出现异常的地方用throw new 自定义对象抛出。</p><p>作用：编译阶段不报错，提醒不强烈，运行时才可能出现！</p><h2 id="第十七天"><a href="#第十七天" class="headerlink" title="第十七天"></a>第十七天</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>程序中的日志可以用来记录程序运行过程中的信息，并可以进行永久存储。</p><p>输出语句的弊端：</p><p>· 信息只能展示在控制台；</p><p>· 不能将其记录到其他的位置（文件，数据库）；</p><p>· 想要取消记录的信息需要修改代码才可以完成；</p><p>· 多线程性能较差；</p><p>日志技术的优势：</p><p>· 可以将系统执行的信息选择性的记录到指定的位置（ 控制台、文件中、数据库中） 。<br>· 可以随时以开关的形式控制是否记录日志， 无需修改源代码。</p><p>· 多线程性能较好；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*日志规范接口 - 提供给日志的实现框架设计的标准</span></span><br><span class="line"><span class="comment">Commons Logging</span></span><br><span class="line"><span class="comment">Simple Logging Facade for Java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*日志实现框架</span></span><br><span class="line"><span class="comment">Log4J</span></span><br><span class="line"><span class="comment">Logback -&gt; 实现了slf4j接口 性能优于Log4J</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Logback</strong></p><p>概述：</p><p>logback 分为三个模块，logback-core、logback-classic 和 logback-access。</p><p>· logback-core 模块为其他两个模块奠定了基础。</p><p>· logback-classic 模块可以同化为 log4j 1.x 的显着改进版本。此外，logback-classic 原生实现了SLF4J API，因此您可以轻松地在 logback 和其他日志框架（例如 log4j 1.x 或 java.util.logging (JUL)）之间来回切换。</p><p>· logback-access 模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能。</p><p><strong>！！需第三方jar包</strong></p><p>入门：</p><p>1.在项目下新建文件夹lib，导入Logback的相关jar包到该目录下，并添加到项目依赖库中去；</p><p>2.将logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）；</p><p>3.在代码中获取日志的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;类对象&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="第十八天"><a href="#第十八天" class="headerlink" title="第十八天"></a>第十八天</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>可以定位文件：进行删除，获取文本信息等操作；</p><p>但不能读写文件内容</p><p>File对象可以定位文件和文件夹</p><p>File封装的对象仅仅是一个路径名，这个路径可以存在也可以不存在；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在操作文件时一定要使用 File.separator 表示分隔符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 path 是实际存在的路径，则该 File 对象表示的是目录；如果 path 是文件名，则该 File 对象表示的是文件。</span></span><br><span class="line"><span class="comment">//支持相对路径（相对到工程下）与绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String path)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//path 是路径名，name 是文件名。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String path, String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dir 是路径对象，name 是文件名。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(File dir, String name)</span>;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>boolean canRead()</td><td style="text-align:center">测试应用程序是否能从指定的文件中进行读取</td></tr><tr><td>boolean canWrite()</td><td style="text-align:center">测试应用程序是否能写当前文件</td></tr><tr><td>boolean delete()</td><td style="text-align:center">删除当前对象指定的文件（占用可删），非空文件夹不能删除；（不走回收站！）</td></tr><tr><td>boolean exists()</td><td style="text-align:center">测试当前 File 是否存在</td></tr><tr><td>String getAbsolutePath()</td><td style="text-align:center">返回由该对象表示的文件的绝对路径名</td></tr><tr><td>String getName()</td><td style="text-align:center">返回表示当前对象的文件名或路径名（如果是路径，则返回最后一级子路径名）</td></tr><tr><td>String getParent()</td><td style="text-align:center">返回当前 File 对象所对应目录（最后一级子目录）的父目录名</td></tr><tr><td>boolean isAbsolute()</td><td style="text-align:center">测试当前 File 对象表示的文件是否为一个绝对路径名。该方法消除了不同平台的差异，可以直接判断 file 对象是否为绝对路径。在 UNIX/Linux/BSD 等系统上，如果路径名开头是一条斜线<code>/</code>，则表明该 File 对象对应一个绝对路径；在 Windows 等系统上，如果路径开头是盘符，则说明它是一个绝对路径。</td></tr><tr><td>boolean isDirectory()</td><td style="text-align:center">测试当前 File 对象表示的文件是否为一个路径</td></tr><tr><td>boolean isFile()</td><td style="text-align:center">测试当前 File 对象表示的文件是否为一个“普通”文件</td></tr><tr><td>long lastModified()</td><td style="text-align:center">返回当前 File 对象表示的文件最后修改的时间</td></tr><tr><td>long length()</td><td style="text-align:center">返回当前 File 对象表示的文件长度</td></tr><tr><td>String[] list()</td><td style="text-align:center">返回当前 File 对象指定的路径文件列表</td></tr><tr><td>String[] list(FilenameFilter)</td><td style="text-align:center">返回当前 File 对象指定的目录中满足指定过滤器的文件列表</td></tr><tr><td>boolean mkdir()</td><td style="text-align:center">创建一个目录，它的路径名由当前 File 对象指定</td></tr><tr><td>boolean mkdirs()</td><td style="text-align:center">创建一个多级目录，它的路径名由当前 File 对象指定</td></tr><tr><td>boolean renameTo(File)</td><td style="text-align:center">将当前 File 对象指定的文件更名为给定参数 File 指定的路径名</td></tr><tr><td>boolean creatNewFile()</td><td style="text-align:center">创建新文件，创建成功返回true，若失败或文件已经存在则返回false（几乎不用）</td></tr><tr><td>File[] listFiles()</td><td style="text-align:center">返回当前目录下所有的”一级文件对象“的一个文件对象数组(常用);调用者不存在，返回null；调用者为一个空文件夹时，返回长度为0的数组；（常用）</td></tr></tbody></table></div><h3 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h3><p>方法直接调用自己，或者间接调用自己的形式称为方法递归(recursion)；</p><p>递归死循环：递归方法无限调用自己，无法终止，出现栈内存溢出；</p><p>递归问题解决的思路：</p><p>~ 把一个复杂的问题层层转化为一个与原问题相似规模较小的问题来解决；</p><p><strong>三要素： 递归公式 递归终点 递归方向 </strong></p><h3 id="文件搜索（方法递归）"><a href="#文件搜索（方法递归）" class="headerlink" title="文件搜索（方法递归）"></a>文件搜索（方法递归）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">目的：从某个盘中，搜索出某个文件名称并输出绝对路径</span></span><br><span class="line"><span class="comment">1.先定位出应该是一级文件对象</span></span><br><span class="line"><span class="comment">2.遍历一遍全部一级文件对象，判断是否为文件</span></span><br><span class="line"><span class="comment">3.如果是文件，判断是否为目标文件</span></span><br><span class="line"><span class="comment">4.如果是文件夹，需要继续递归进去重复上述过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir,String fileName)</span>&#123;</span><br><span class="line">    <span class="comment">//判断dir是否为目录</span></span><br><span class="line">    <span class="keyword">if</span>(dir != <span class="literal">null</span> &amp;&amp; dir.isDirectory)&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(file.getName().contains(fileName))&#123;</span><br><span class="line">                        <span class="comment">//输出绝对路径；</span></span><br><span class="line">                        System.out.println(file.getAbsolutePath());</span><br><span class="line">                        <span class="comment">//启动文件</span></span><br><span class="line">                        <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRunTime();</span><br><span class="line">                        r.exec(file.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    searchFile(file,fileName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p><strong>ASCII</strong>字符集：包括了数字，英文，符号，使用一个字节存储一个字符，可以表示128个字符信息；</p><p><strong>GBK</strong>字符集：Windows默认码表，兼容ASCII码表，也包括了几万个汉字，并支持繁体汉字以及部分日韩文字；两个字节表示一个中文；</p><p><strong>Unicode</strong>码表：又称万国码，容纳世界上大多数国家的所有常见位置和符号；三个字节表示一个中文； </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;abc我爱你中国&quot;</span>;<span class="comment">//18个字节</span></span><br><span class="line"><span class="type">byte</span>[] bytes = name.getBytes(<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//以当前代码默认字符集进行编码（UTF-8）</span></span><br><span class="line"><span class="comment">//解码(编码前与编码后的字符集必须一致)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//默认UTF-</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>输入输出流，用来读写数据的；</p><p>按流中数据最小单位划分：字节流，字符流；</p><h4 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h4><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：</p><p>（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p><p>（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p><p>（3）字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；而字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件，我们将在下面验证这一点。</p><p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p><h4 id="输入字节流InputStream"><a href="#输入字节流InputStream" class="headerlink" title="输入字节流InputStream"></a>输入字节流InputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">FileInputStream</span></span><br><span class="line"><span class="comment">以内存为基准，把磁盘中的数据以字节的形式读取到内存中去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(File file)</span> <span class="comment">//创建字节输入流管道与源文件对象接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String pathName)</span> <span class="comment">//创建字节输入流管道与源文件路径接通</span></span><br><span class="line"><span class="comment">//常用API</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="comment">//每次读取一个字节返回，如果没有字节可以返回，则返回-1；</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> <span class="comment">//每次读取一个字节数组并返回读取长度，如果没有字节可以返回，则返回-1</span></span><br><span class="line"><span class="comment">//循环读入的时候buffer转String时采用 new String(byte[] bytes,int offset,int len)构造，避免数组未读满时，会将上次读取的字节重新转换；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**如何使用字节输入流读取中文内容输出不乱码？</span></span><br><span class="line"><span class="comment">    1.定义一个与文件大小一样大的字节数组，一次性读取完文件所有字节</span></span><br><span class="line"><span class="comment">    带来的问题：如果文件过大，字节数组可能引起内存溢出</span></span><br><span class="line"><span class="comment">    byte[] buffer = (new FileINputStream(String patnName)).readAllBytes;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="输出字节流OutputStream"><a href="#输出字节流OutputStream" class="headerlink" title="输出字节流OutputStream"></a>输出字节流OutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">FileOutputStream</span></span><br><span class="line"><span class="comment">以内存为基准，把内存中中的数据以字节的形式写入到磁盘中去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file)</span> <span class="comment">//创建字节输出流管道与源文件对象接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String pathName)</span> <span class="comment">//创建字节输出流管道与源文件路径接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String pathName，<span class="type">boolean</span> append)</span> <span class="comment">//创建字节输出流管道与源文件路径接通 append为true时追加</span></span><br><span class="line"><span class="comment">//常用API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//将一个字节写出去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer)</span> <span class="comment">//每次输出一个字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] bytes,<span class="type">int</span> offset,<span class="type">int</span> len)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span><span class="comment">//刷新流，但能继续写数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span><span class="comment">//关闭流，释放资源，但是会在关闭前刷新流，一旦关闭，则不能继续写数据；</span></span><br><span class="line"><span class="comment">/**如何使用字节输入流读取中文内容输出不乱码？</span></span><br><span class="line"><span class="comment">    1.定义一个与文件大小一样大的字节数组，一次性读取完文件所有字节</span></span><br><span class="line"><span class="comment">    带来的问题：如果文件过大，字节数组可能引起内存溢出</span></span><br><span class="line"><span class="comment">    byte[] buffer = (new FileINputStream(String patnName)).readAllBytes;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//回车用&quot;\r\n&quot;，然后转成字节数组即可</span></span><br></pre></td></tr></table></figure><h4 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h4><p><strong>try-catch-finally</strong></p><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>在关闭流的时候，要对流进行校验是否为空，为空会抛出空指针异常；</p><p><strong>try-with-resource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>( <span class="comment">//这里只能放置资源对象，用完会自动关闭，自动调用对象的close()方法关闭资源，即使出现异常也会关闭</span></span><br><span class="line">        <span class="comment">//资源都是实现了Closeable/AutoCloseable接口的对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> input.read();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输入字符流Read"><a href="#输入字符流Read" class="headerlink" title="输入字符流Read"></a>输入字符流Read</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">FileReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(File file)</span> <span class="comment">//创建字符输入流管道与源文件对象接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String pathName)</span> <span class="comment">//创建字符输入流管道与源文件路径接通</span></span><br><span class="line"><span class="comment">//常用API</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="comment">//每次读取一个字符返回，如果没有字符可以返回，则返回-1；</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> <span class="comment">//每次读取一个字符数组并返回读取长度，如果没有字符可以返回，则返回-1</span></span><br></pre></td></tr></table></figure><h4 id="输出字符流Writer"><a href="#输出字符流Writer" class="headerlink" title="输出字符流Writer"></a>输出字符流Writer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">FileWriter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file)</span> <span class="comment">//创建字符输出流管道与源文件对象接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String pathName)</span> <span class="comment">//创建字符输出流管道与源文件路径接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String pathName，<span class="type">boolean</span> append)</span> <span class="comment">//创建字符输出流管道与源文件路径接通 append为true时追加</span></span><br><span class="line"><span class="comment">//常用API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span><span class="comment">//将一个字符写出去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] buffer)</span> <span class="comment">//每次输出一个字符数组，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] bytes,<span class="type">int</span> offset,<span class="type">int</span> len)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> <span class="comment">//每次输出一个字符串，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str,<span class="type">int</span> offset,<span class="type">int</span> len)</span></span><br></pre></td></tr></table></figure><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><p>作用：缓冲流自带缓冲区，可以提高原始字节流，字符流读写数据的性能；</p><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>自带8KB的缓冲池</p><p><strong>BufferInputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级的字节输入流包装成一个高级的缓冲字节输入管道，从而提高字节输入流读数据的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferInputStream</span><span class="params">(InputStream is)</span></span><br></pre></td></tr></table></figure><p><strong>BufferOutputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级的字节输出流包装成一个高级的缓冲字节输出管道，从而提高字节输出流写数据的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferOutputStream</span><span class="params">(OutputStream os)</span></span><br></pre></td></tr></table></figure><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p><strong>BufferReader</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级的字符输入流包装成一个高级的缓冲字符输入管道，从而提高字符输入流读数据的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferReader</span><span class="params">(Reader r)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增API</span></span><br><span class="line"><span class="comment">//读取一行数据返回，如果读取没有完毕，无行可读返回null</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readLine</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>BufferWriter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级的字符输出流包装成一个高级的缓冲字符输出管道，从而提高字符输出流写数据的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferWriter</span><span class="params">(Writer w)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//新增API</span></span><br><span class="line"><span class="comment">//换行操作</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">newLine</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p><strong>InputStreamReader</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将原始的字节输入流按照代码的默认编码转换成字符输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream is)</span> <span class="comment">//（几乎不用）</span></span><br><span class="line"><span class="comment">//可以将原始的字节输入流按照指定编码转换成字符输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream is，String charset)</span> <span class="comment">//常用</span></span><br></pre></td></tr></table></figure><p><strong>OutputStreamWriter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将原始的字节输出流按照代码的默认编码转换成字符输出流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream os)</span> <span class="comment">//（几乎不用）</span></span><br><span class="line"><span class="comment">//可以将原始的字节输入流按照指定编码转换成字符输出流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream os，String charset)</span> <span class="comment">//常用</span></span><br></pre></td></tr></table></figure><h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>作用：以内存为基准，把内存中的对象存储到磁盘中去，称为对象序列化</p><p><strong>对象字节输出流ObjectOutputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级字节输出流包装成高级的对象字节输出流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream os)</span></span><br><span class="line"><span class="comment">//常用方法 ps:对象如果要序列化，必须实现Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object o)</span></span><br></pre></td></tr></table></figure><h4 id="对象的反序列化"><a href="#对象的反序列化" class="headerlink" title="对象的反序列化"></a>对象的反序列化</h4><p>作用：以内存为基准，把磁盘中的对象数据恢复成内存中的对象，称为对象反序列化</p><p><strong>对象字节输入流ObjectInputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级字节输入流包装成高级的对象字节输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream is)</span></span><br><span class="line"><span class="comment">//常用方法 ps:对象如果要序列化，必须实现Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">readObject</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>关键字transient</strong></p><p>修饰的成员不参与序列化；</p><p><strong>序列化版本号</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化的版本号要与反序列化的版本一致</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID;</span><br></pre></td></tr></table></figure><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>作用：打印流可以实现方便、高效的打印数据到文件中去；</p><p><strong>PrintStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层包装了缓冲流</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream os)</span><span class="comment">//打印流直接通向字节输出管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(File f)</span><span class="comment">//打印流直接通向文件对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(String filePath)</span><span class="comment">//打印流直接通向文件路径</span></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>PrintWrite</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印功能与PrintStream无区别，只不过支持字符数据输出，而PrintStream只能写字节</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWrite</span><span class="params">(OutputStream os)</span><span class="comment">//打印流直接通向字节输出管道</span></span><br><span class="line"><span class="keyword">public</span> PrintWriteWriter w) <span class="comment">//打印流直接通向字符输出管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWrite</span><span class="params">(File f)</span><span class="comment">//打印流直接通向文件对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWrite</span><span class="params">(String filePath)</span><span class="comment">//打印流直接通向文件路径</span></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>若打印流要进行追加，只能用低级管道构造打印流；</p><p><strong>输出语句重定向</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setOut(PrintSream ps)</span><br></pre></td></tr></table></figure><h4 id="Properties属性集对象"><a href="#Properties属性集对象" class="headerlink" title="Properties属性集对象"></a>Properties属性集对象</h4><p>是Map集合的实现类</p><p>作用：代表一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。</p><p>属性文件：后缀是.properties结尾的文件，内容为key=value，用来做系统配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">setProperty</span><span class="params">(String key, String value)</span>  <span class="comment">//保存一对属性。  (put)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> <span class="comment">//使用此属性列表中指定的键搜索属性值 (get)</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">stringPropertyNames</span><span class="params">()</span>  <span class="comment">//所有键的名称的集合  (keySet())</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(OutputStream out, String comments)</span> <span class="comment">//保存数据到属性文件中去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(Writer fw, String comments)</span> <span class="comment">//保存数据到属性文件中去</span></span><br><span class="line"><span class="comment">//加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(InputStream inStream)</span><span class="comment">//加载属性文件的数据到属性集对象中去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(Reader fr)</span><span class="comment">//加载属性文件的数据到属性集对象中去</span></span><br></pre></td></tr></table></figure><h4 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h4><p><strong>commons-io</strong>是apache开源基金组织提供的一组有关IO操作的类库，<br>可以挺提高IO功能开发的效率。commons-io工具包提供了很多有关io操作的类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件中的数据, 返回字符串</span></span><br><span class="line">String <span class="title function_">readFileToString</span><span class="params">(File file, String encoding)</span></span><br><span class="line"><span class="comment">//复制文件</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile, File destFile)</span></span><br><span class="line"><span class="comment">//复制文件夹</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copyDirectoryToDirectory</span><span class="params">(File srcDir, File destDir)</span></span><br><span class="line"><span class="comment">//删除文件夹</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteDirectory</span><span class="params">(File f)</span></span><br></pre></td></tr></table></figure><h2 id="第十九天"><a href="#第十九天" class="headerlink" title="第十九天"></a>第十九天</h2><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p><strong>线程</strong>是一个程序内部的一条执行路径</p><p>main方法的执行就是一条单独的路径</p><p><strong>多线程</strong>是指软硬件上实现多条执行流程的技术</p><h5 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h5><p><strong>方法一：继承Thread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1.定义一个子类MyThread继承线程类Java.lang.Thread，重写run()方法</span></span><br><span class="line"><span class="comment">2.创建MyThread类的对象</span></span><br><span class="line"><span class="comment">3.调用线程对象的start()方法启动线程(启动之后还是执行run方法)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//new一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优缺点</span></span><br><span class="line"><span class="comment">//优点：编码简单</span></span><br><span class="line"><span class="comment">//缺点：线程类以及继承Thread，无法继承其他类，不利于扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么不直接调用run方法，而是调用start启动线程？</span></span><br><span class="line"><span class="comment">//调用run方法会被当成单线程，而不是多线程！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么不能把主线程的任务放在子线程之前？</span></span><br><span class="line"><span class="comment">//这样的话主线程一直都是先跑完的，相当于一个单线程的效果</span></span><br></pre></td></tr></table></figure><p><strong>方法二 实现Runnable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">实现方案一：</span></span><br><span class="line"><span class="comment">1.定义一个线程任务类实现Runnable接口，重写run()方法</span></span><br><span class="line"><span class="comment">2.创建MyRunnable任务对象</span></span><br><span class="line"><span class="comment">3.把任务对象交给Thread处理</span></span><br><span class="line"><span class="comment">4.调用线程对象的start()方法启动线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//new一个任务对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Thread构造器，构造一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">实现方案二（匿名内部类）：</span></span><br><span class="line"><span class="comment">1.创建Runnable的匿名内部类</span></span><br><span class="line"><span class="comment">2.把任务对象交给Thread处理</span></span><br><span class="line"><span class="comment">3.调用线程对象的start()方法启动线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//new一个Runnable实例（匿名内部类重写run()方法）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Thread构造器，构造一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(String name)</span><span class="comment">//为当前线程指定名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span><span class="comment">//封装Runnable对象为线程对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target,String name)</span><span class="comment">//封装Runnable对象尾线程对象，并指定线程名称    </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//优缺点</span></span><br><span class="line"><span class="comment">//优点线程任务类只是实现接口，可以继承类和实现接口，拓展性强。</span></span><br><span class="line"><span class="comment">//缺点编程多一层对象包装，如果线程有执行结果是不可以直接返回的（run()方法无返回值）</span></span><br></pre></td></tr></table></figure><p><strong>方法三 Callable，FutureTask接口</strong></p><p>方法一和方法二都存在一个问题：无返回结果！</p><p>解决方法：Callable和FutureTask来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**：</span></span><br><span class="line"><span class="comment">1.定义一个线程任务类实现Callable接口，重写call()方法</span></span><br><span class="line"><span class="comment">2.用FutureTask把Callable对象封装成线程任务对象</span></span><br><span class="line"><span class="comment">3.把任务对象交给Thread处理</span></span><br><span class="line"><span class="comment">4.调用线程对象的start()方法启动线程</span></span><br><span class="line"><span class="comment">5，线程执行完毕后，通过FutureTask的get()方法去获取任务执行结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    pubulic <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;子线程执行的结果是&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//new一个Callable任务对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将Callable对象交给FutureTask对象  </span></span><br><span class="line">        <span class="comment">//FutureTask作用1：是Runnable的对象，实现了Runnable接口，可以交给Thread；</span></span><br><span class="line">        <span class="comment">//FutureTask作用2：可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果；</span></span><br><span class="line">        FutureTask&lt;String&gt; f = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Thread构造器，构造一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取返回值</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果f任务未执行完毕，这里代码会等待到任务执行完毕才提取结果；</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> f.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优缺点</span></span><br><span class="line"><span class="comment">//优点线程任务类只是实现接口，可以继承类和实现接口，拓展性强。</span></span><br><span class="line"><span class="comment">// 可以在线程执行完毕后去获取线程执行结果</span></span><br><span class="line"><span class="comment">//缺点代码复杂</span></span><br></pre></td></tr></table></figure><h4 id="Thread类常用API"><a href="#Thread类常用API" class="headerlink" title="Thread类常用API"></a>Thread类常用API</h4><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>public void interrupt()</strong> 中断线程。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td></tr></tbody></table></div><p><strong>静态方法</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td></tr></tbody></table></div><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题。</p><p>原因：存在多线程并发，同时访问共享资源，存在修改共享资源；                    </p><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>· 为了解决线程安全问题</p><p>· 让多个线程实现先后依次访问共享资源，这样就解决了安全问题；</p><p><strong>核心思想</strong></p><p>1.加锁    把共享资源进行上锁，每次只能 一个线程进入访问，访问完毕以后解锁，然后其他线程才能进来；</p><p><strong>方法一：同步代码块</strong></p><p>作用：把出现线程安全问题的核心代码给上锁</p><p>原理：每次只能 一个线程进入访问，访问完毕以后解锁，然后其他线程才能进来；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(同步锁对象)&#123;</span><br><span class="line">    <span class="comment">//操作共享资源的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//锁对象要求：对于当前同时执行的线程来说是同一个对象即可；-&gt;用字符串命名</span></span><br><span class="line"><span class="comment">//不能使用在方法内new出来的对象，这样对于当前同时执行的线程来说就不是同一个对象；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//锁对象用任意唯一的对象的问题：会影响到其他无关线程执行；</span></span><br><span class="line"><span class="comment">//规范上：建议使用共享资源作为锁对象</span></span><br><span class="line"><span class="comment">//对于实例方法建议使用this作为锁对象</span></span><br><span class="line"><span class="comment">//对于静态方法建议使用字节码（类名.class）对象作为锁对象</span></span><br></pre></td></tr></table></figure><p><strong>方法二：同步方法</strong></p><p>作用：把出现线程安全问题的核心方法给上锁</p><p>原理：每次只能 一个线程进入访问，访问完毕以后解锁，然后其他线程才能进来；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">修饰符 synchronized 返回值类型 方法名称(形参列表)&#123;</span></span><br><span class="line"><span class="comment">操作共享资源的代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//底层原理：隐式锁对象，只是锁的范围是整个方法代码。</span></span><br><span class="line"><span class="comment">//如果方法是实例方法：同步方法默认用this作为锁的对象，但是代码要高度面向对象。</span></span><br><span class="line"><span class="comment">//如果方法是静态方法：同步方法默认用类名.class作为锁的对象。</span></span><br></pre></td></tr></table></figure><p><strong>同步代码块锁的范围更小，同步方法锁的范围更大</strong></p><p><strong>方法三：Lock锁</strong></p><p>· 为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。</p><p>· Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</p><p>· Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取实现类对象（通常用final修饰）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//API</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> <span class="comment">//获得锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span><span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure><h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>线程间相互发送数据；</p><p><strong>常见形式</strong></p><p>1.通过共享一个数据的方式实现</p><p>2.根据共享数据的情况决定自己该怎么做，已经通知其他线程怎么做</p><p><strong>线程通信实际应用场景</strong></p><p>1.生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</p><p>​    要求：生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。</p><h4 id="Object类等待和唤醒方法"><a href="#Object类等待和唤醒方法" class="headerlink" title="Object类等待和唤醒方法"></a>Object类等待和唤醒方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span><span class="comment">//让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span><span class="comment">//唤醒正在等待的单个线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span><span class="comment">//唤醒正在等待的所有线程 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：上述方法应该使用当前同步锁对象进行调用。</span></span><br></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>可以复用线程的技术</p><p><strong>不使用线程池的问题</strong></p><p>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</p><p><strong>线程池实现的API，参数说明</strong></p><p>接口：ExecutorService</p><p><strong>如何得到线程池对象</strong></p><p>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象（推荐使用，参数可控）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,                  //指定线程池的线程数量（核心线程）不能小于零        </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,               //指定线程池可支持的最大线程数 最大数量大于核心线程数 </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,                //指定临时线程的最大存活时间  不能小于零         </span></span><br><span class="line"><span class="params">                          TimeUnit unit,                     //指定存活时间的单位时间单位    </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, //指定任务队列  不能为<span class="literal">null</span>        </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,       //指定用哪个线程工厂创建线程  不能为<span class="literal">null</span>         </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>  <span class="comment">//指定线程忙任务满的时候，新任务解决方式 不能为null</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>新任务拒绝策略</p><div class="table-container"><table><thead><tr><th>策略</th><th>详解</th></tr></thead><tbody><tr><td>ThreadPoolExecutor.AbortPolicy</td><td>丢弃任务并抛出RejectedExecutionException异常。<strong>是默认的策略</strong></td></tr><tr><td>ThreadPoolExecutor.DiscardPolicy：</td><td>丢弃任务，但是不抛出异常  这是不推荐的做法</td></tr><tr><td>ThreadPoolExecutor.DiscardOldestPolicy</td><td>抛弃队列中等待最久的任务  然后把当前任务加入队列中</td></tr><tr><td>ThreadPoolExecutor.CallerRunsPolicy</td><td>由主线程负责调用任务的run()方法从而绕过线程池直接执行</td></tr></tbody></table></div><p>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象（不推荐使用）</p><p>Executors：线程池的工具类通过调用方法返回不同类型的线程池对象。</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名称</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">public  static ExecutorService newCachedThreadPool()</td><td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td></tr><tr><td style="text-align:left">public static ExecutorService newFixedThreadPool(int nThreads)</td><td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td></tr><tr><td style="text-align:left">public  static ExecutorService newSingleThreadExecutor ()</td><td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td></tr><tr><td style="text-align:left">public  static ExecutorService newScheduledThreadPool(int corePoolSize)</td><td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td></tr></tbody></table></div><p><strong>注意：Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的</strong></p><p><strong>Executor使用可能存在的陷阱</strong></p><p>大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</p><div class="table-container"><table><thead><tr><th>方法名称</th><th>存在问题</th></tr></thead><tbody><tr><td>public  static ExecutorService newFixedThreadPool(int nThreads)</td><td>允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误（ java.lang.OutOfMemoryError ）</td></tr><tr><td>public  static ExecutorService newSingleThreadExecutor()</td><td></td></tr><tr><td>public  static ExecutorService newCachedThreadPool()</td><td>创建的线程数量最大上限是Integer.MAX_VALUE，  线程数可能会随着任务1:1增长，也可能出现OOM错误（ java.lang.OutOfMemoryError ）</td></tr><tr><td>public  static ExecutorService newScheduledThreadPool(int corePoolSize)</td></tr></tbody></table></div><p><strong>常见问题：</strong></p><p><strong>1.临时线程什么时候创建啊？</strong></p><p>新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。</p><p><strong>2.什么时候会开始拒绝任务？</strong></p><p>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。</p><p><strong>ExecutorService常用API</strong></p><div class="table-container"><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行任务/命令，没有返回值，一般用来执行  Runnable 任务</td></tr><tr><td>Future<T>  submit(Callable<T> task)</td><td>执行任务，返回未来任务对象获取线程结果，一般拿来执行  Callable 任务</td></tr><tr><td>void  shutdown()</td><td>等任务执行完毕后关闭线程池</td></tr><tr><td>List<Runnable>shutdownNow()</td><td>立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</td></tr></tbody></table></div><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>定时器是一种控制任务延时调用，或周期调用技术。</p><p>作用：闹钟、定时邮件发送。</p><p><strong>实现方式</strong></p><p>1.Timer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//API</span></span><br><span class="line"><span class="comment">//开启一个定时器，按照计划处理TimerTask任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,<span class="type">long</span> delay,<span class="type">long</span> period)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//特点：</span></span><br><span class="line"><span class="comment">//Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</span></span><br><span class="line"><span class="comment">//问题：</span></span><br><span class="line"><span class="comment">//可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.ScheduledExecutorService</p><p>ScheduledExecutorService是 jdk1.5中引入了并发包，<strong>目的是为了弥补Timer的缺陷,</strong> ScheduledExecutorService内部为线程池。</p><div class="table-container"><table><thead><tr><th>Executors的方法</th><th>说明</th></tr></thead><tbody><tr><td>public static ScheduledExecutorService <strong>newScheduledThreadPool</strong>(int corePoolSize)</td><td>得到线程池对象</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>ScheduledExecutorService的方法</th><th>说明</th></tr></thead><tbody><tr><td>public ScheduledFuture&lt;?&gt; <strong>scheduleAtFixedRate</strong>(Runnable command, long initialDelay, long period,                              TimeUnit unit)</td><td>周期调度方法</td></tr></tbody></table></div><p><strong>ScheduledExecutorService的优点</strong></p><p>1、基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</p><h4 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发 并行"></a>并发 并行</h4><p>正在运行的程序（软件）就是一个独立的进程， 线程是属于进程的，多个线程其实是并发与并行同时进行的。</p><p><strong>并发的理解</strong></p><p>1.CPU同时处理线程的数量有限。</p><p>2.CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p><strong>状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6种状态都定义在Thread类的内部枚举类中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">     ...  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;    </span><br><span class="line">     NEW,   </span><br><span class="line">     RUNNABLE,    </span><br><span class="line">     BLOCKED,    </span><br><span class="line">     WAITING,   </span><br><span class="line">     TIMED_WAITING,   </span><br><span class="line">     TERMINATED;    </span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二十天"><a href="#第二十天" class="headerlink" title="第二十天"></a>第二十天</h2><h3 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h3><pre><code>* 测试分类：    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。    2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试    * 步骤：        1. 定义一个测试类(测试用例)            * 建议：                * 测试类名：被测试的类名Test        CalculatorTest                * 包名：xxx.xxx.xx.test        cn.itcast.test        2. 定义测试方法：可以独立运行            * 建议：                * 方法名：test测试的方法名        testAdd()                  * 返回值：void                * 参数列表：空参        3. 给方法加@Test        4. 导入junit依赖环境    * 判定结果：        * 红色：失败        * 绿色：成功        * 一般我们会使用断言操作来处理结果            * Assert.assertEquals(期望的结果,运算的结果);    * 补充：        * @Before:            * 修饰的方法会在测试方法之前被自动执行        * @After:            * 修饰的方法会在测试方法执行之后自动被执行</code></pre><h3 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h3><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制    * 好处：        1. 可以在程序运行过程中，操作这些对象。        2. 可以解耦，提高程序的可扩展性。* 获取Class对象的方式：    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类    2. 类名.class：通过类名的属性class获取        * 多用于参数的传递    3. 对象.getClass()：getClass()方法在Object类中定义着。        * 多用于对象的获取字节码的方式    * 结论：        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。* Class对象功能：    * 获取功能：        1. 获取成员变量们            * Field[] getFields() ：获取所有public修饰的成员变量            * Field getField(String name)   获取指定名称的 public修饰的成员变量            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符            * Field getDeclaredField(String name)          2. 获取构造方法们            * Constructor&lt;?&gt;[] getConstructors()              * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;?&gt;[] getDeclaredConstructors()          3. 获取成员方法们：            * Method[] getMethods()              * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)              * Method[] getDeclaredMethods()              * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)          4. 获取全类名                * String getName()  * Field：成员变量    * 操作：        1. 设置值            * void set(Object obj, Object value)          2. 获取值            * get(Object obj)         3. 忽略访问权限修饰符的安全检查            * setAccessible(true):暴力反射* Constructor:构造方法    * 创建对象：        * T newInstance(Object... initargs)          * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法* Method：方法对象    * 执行方法：        * Object invoke(Object obj, Object... args)      * 获取方法名称：        * String getName:获取方法名* 案例：    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法        * 实现：            1. 配置文件            2. 反射        * 步骤：            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中            2. 在程序中加载读取配置文件            3. 使用反射技术来加载类文件进内存            4. 创建对象            5. 执行方法</code></pre><h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><pre><code>* 概念：说明程序的。给计算机看的* 注释：用文字描述程序的。给程序员看的* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。* 概念描述：    * JDK1.5之后的新特性    * 说明程序的    * 使用注解：@注解名称</code></pre><p>​    </p><pre><code>* 作用分类：    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】* JDK中预定义的一些注解    * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的    * @Deprecated：该注解标注的内容，表示已过时    * @SuppressWarnings：压制警告        * 一般传递参数all  @SuppressWarnings(&quot;all&quot;)* 自定义注解    * 格式：        元注解        public @interface 注解名称&#123;            属性列表;        &#125;    * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口        * public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125;    * 属性：接口中的抽象方法        * 要求：            1. 属性的返回值类型有下列取值                * 基本数据类型                * String                * 枚举                * 注解                * 以上类型的数组            2. 定义了属性，在使用时需要给属性赋值                1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。                2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。                3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略    * 元注解：用于描述注解的注解        * @Target：描述注解能够作用的位置            * ElementType取值：                * TYPE：可以作用于类上                * METHOD：可以作用于方法上                * FIELD：可以作用于成员变量上        * @Retention：描述注解被保留的阶段            * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到        * @Documented：描述注解是否被抽取到api文档中        * @Inherited：描述注解是否被子类继承* 在程序使用(解析)注解：获取注解中定义的属性值    1. 获取注解定义的位置的对象  （Class，Method,Field）    2. 获取指定的注解        * getAnnotation(Class)        //其实就是在内存中生成了一个该注解接口的子类实现对象                public class ProImpl implements Pro&#123;                    public String className()&#123;                        return &quot;cn.itcast.annotation.Demo1&quot;;                    &#125;                    public String methodName()&#123;                        return &quot;show&quot;;                    &#125;                &#125;    3. 调用注解中的抽象方法获取配置的属性值* 案例：简单的测试框架* 小结：    1. 以后大多数时候，我们会使用注解，而不是自定义注解    2. 注解给谁用？        1. 编译器        2. 给解析程序用    3. 注解不是程序的一部分，可以理解为注解就是一个标签</code></pre><h1 id="Java基础完结！！！！！！！！！！！！！！！"><a href="#Java基础完结！！！！！！！！！！！！！！！" class="headerlink" title="Java基础完结！！！！！！！！！！！！！！！"></a>Java基础完结！！！！！！！！！！！！！！！</h1>]]></content>
    
    
    <summary type="html">Java基础的学习笔记</summary>
    
    
    
    <category term="后台成长历程" scheme="https://blog.hiles.cn/categories/%E5%90%8E%E5%8F%B0%E6%88%90%E9%95%BF%E5%8E%86%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://blog.hiles.cn/tags/java/"/>
    
  </entry>
  
</feed>
