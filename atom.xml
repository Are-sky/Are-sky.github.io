<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Helios Blog</title>
  
  <subtitle>即使没有月亮，心中也是一片皎洁。</subtitle>
  <link href="https://blog.hiles.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.hiles.cn/"/>
  <updated>2023-03-28T13:41:05.669Z</updated>
  <id>https://blog.hiles.cn/</id>
  
  <author>
    <name>Helios</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网</title>
    <link href="https://blog.hiles.cn/posts/bdbd2d9.html"/>
    <id>https://blog.hiles.cn/posts/bdbd2d9.html</id>
    <published>2023-03-28T13:04:57.000Z</published>
    <updated>2023-03-28T13:41:05.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p><img src="https://pic2.zhimg.com/80/v2-72754ddc9c8133906ade003ad4a346d5_720w.webp" alt="alt text"></p><ul><li><p>应用层<br>最上层的，也是我们能直接接触到的就是应用层（Application Layer），我们电脑或手机使用的应用软件都是在应用层实现。</p><p>应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p></li><li><p>传输层<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4%40main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="Alt text"><br>应用层的数据包会传给传输层，传输层（<strong>Transport Layer</strong>）是为应用层提供网络支持的。</p><p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p><strong>TCP</strong>的全称叫传输控制协议（<strong>Transmission Control Protocol</strong>），TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。<br><strong>UDP</strong>只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。DP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以。<br>当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。<br>在 TCP 协议中，我们把每个分块称为一个 TCP 段（<strong>TCP Segment</strong>）。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4%40main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png" alt="Alt text"><br>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。<br>比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。<br>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用</p></li><li><p>网络层<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4%40main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="Alt text"><br>网络层最常使用的是 IP 协议（<strong>Internet Protocol</strong>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="Alt text"><br>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。</p><ul><li><strong>IP 地址</strong><br>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；<br>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；<br>需要配合子网掩码才能算出 IP 地址 的网络号和主机号。<br>举个例子，比如 10.100.122.0/24，后面的/24表示就是 255.255.255.0 子网掩码;<br>知道了子网掩码，该怎么计算出网络地址和主机地址呢？<br>将 10.100.122.2 和 255.255.255.0 进行按位与运算，就可以得到网络号，如下图：<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg" alt="Alt text"><br>将 255.255.255.0 取反后与IP地址进行进行按位与运算，就可以得到主机号。</li></ul><p>那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。<br>除了寻址能力， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。<br>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。<br>所以，IP 协议的寻址作用是<font color=Red>告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。</font></p></li><li>网络接口层<br>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4%40main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="Alt text"><br>网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。<br>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。<br>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>CP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4%40main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="Alt text"><br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3%40main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="Alt text"><br>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计网&quot;&gt;&lt;a href=&quot;#计网&quot; class=&quot;headerlink&quot; title=&quot;计网&quot;&gt;&lt;/a&gt;计网&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mysql笔记</title>
    <link href="https://blog.hiles.cn/posts/49658f74.html"/>
    <id>https://blog.hiles.cn/posts/49658f74.html</id>
    <published>2023-03-11T08:48:10.000Z</published>
    <updated>2023-03-11T08:55:33.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p><strong>SQL</strong>——操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准</p><p><strong>关系型数据库</strong>——建立在关系模型上，由多张相互连接的二维表组成的数据库；</p><p>特点：1.使用表存储数据，格式统一，便于维护</p><p>​            2.使用sql语言操作，标准统一，使用方便</p><p>数据模型——数据库+表</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><p>1.SQL语句可以单行或多行书写，以分号结尾；</p><p>2.SQL语句可以使用空格/缩进来增强语句的可读性；</p><p>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写；</p><p>4.注释：</p><p>​    · 单行注释：—注释内容或# 注释内容（MySQL特有）</p><p>​    ·多行注释：/<em>注释内容 </em>/</p><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>数据定义语言，用来定义数据库对象（数据库，表，字段）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 查询数据库</span><br><span class="line"># 查询所有数据库</span><br><span class="line">SHOW DATABASES;</span><br><span class="line"># 查询当前的数据库</span><br><span class="line">SELECT DATABASE();</span><br><span class="line"># 创建数据库 字符集推荐（utf8mb4）</span><br><span class="line">CREATE DATABASE[IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集][COLLATE 排序规则];</span><br><span class="line"># 删除数据库</span><br><span class="line">DROP DATABASE[IF EXISTS] 数据库名;</span><br><span class="line"># 使用数据库</span><br><span class="line">USE 数据库名;</span><br><span class="line"></span><br><span class="line">#表操作——查询</span><br><span class="line">#查询当前数库的所有表</span><br><span class="line">SHOW TABLES;</span><br><span class="line">#查询表结构</span><br><span class="line">DESC 表名;</span><br><span class="line">#查询指定表的建表语句</span><br><span class="line">SHOW CREATE TABLE 表名;</span><br><span class="line"></span><br><span class="line">#表操作——创建 最后一个字段后面没有逗号</span><br><span class="line">CREATE TABLE 表名&#123;</span><br><span class="line">字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">字段2 字段2类型[COMMENT 字段2注释],</span><br><span class="line">字段3 字段3类型[COMMENT 字段3注释],</span><br><span class="line">......</span><br><span class="line">字段N 字段N类型[COMMENT 字段N注释]</span><br><span class="line">&#125;[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line">#表操作——修改</span><br><span class="line">#添加字段</span><br><span class="line">ALTER TABLE ADD 字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line">#修改数据类型</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line">#修改字段名和字段类型</span><br><span class="line">ALTER TABLE CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line">#删除字段</span><br><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br><span class="line">#修改表名</span><br><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br><span class="line"></span><br><span class="line">#表操作——删除</span><br><span class="line">#删除表</span><br><span class="line">DROP TABLE[IF EXISTS] 表名;</span><br><span class="line">#删除指定表并重新创建该表</span><br><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure><p><strong>数值类型</strong></p><div class="table-container"><table><thead><tr><th>类型</th><th>大小</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 byte</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 bytes</td><td>(-32768，32767)</td><td>(0，65535)1</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 bytes</td><td>(-8388608，8388607)</td><td>(0，16777215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 bytes</td><td>(-2147483648，2147483647)</td><td>(0，4294967295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 bytes</td><td>(-2^63，2^63-1)</td><td>(0，2^64-1)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 bytes</td><td>(-3.402823466  E+38，3.402823466351 E+38)</td><td>0 和 (1.175494351 E-38，3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8 bytes</td><td>(-1.7976931348623157  E+308，1.7976931348623157  E+308)</td><td>0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>依赖于M(精度)和D(标度)的值</td><td>依赖于M(精度)和D(标度)的值</td><td>小数值(精确定点数)</td></tr></tbody></table></div><p>精度：数的长度</p><p>标度：小数点后的位数</p><p><strong>字符串类型</strong></p><div class="table-container"><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table></div><p><strong>日期时间类型</strong></p><div class="table-container"><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01 至  9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59 至  838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901 至 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table></div><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>数据操作语言，用来对数据库表中的数据进行增删改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#添加数据</span><br><span class="line">#给指定字段添加数据</span><br><span class="line">INSERT INTO 表名(字段1,字段2,......) VALUES(值1,值2,......);</span><br><span class="line">#给全部字段添加数据</span><br><span class="line">INSERT INTO 表名 VALUES(值1,值2,......);</span><br><span class="line">#批量增加数据</span><br><span class="line">INSERT INTO 表名(字段1,字段2,......) VALUES(值1,值2,......),(值1,值2,......),(值1,值2,......);</span><br><span class="line">NSERT INTO 表名 VALUES(值1,值2,......),(值1,值2,......),(值1,值2,......);</span><br><span class="line">/*</span><br><span class="line">1.插入数据时，指定的字段顺序需要于值的顺序一致</span><br><span class="line">2.字符串和日期型数据应该包含在引号中</span><br><span class="line">3.插入数据的大小，应该在字段的规定范围内</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#修改数据</span><br><span class="line">#修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的数据。</span><br><span class="line">UPDATE 表名 SET 字段1=值1,字段2=值2,...[WHERE 条件];</span><br><span class="line"></span><br><span class="line">#删除数据</span><br><span class="line">#删除语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的数据。</span><br><span class="line">#不能删除某一个字段的值（可以使用UPDATE语句）</span><br><span class="line">DELETE FROM 表名 [WHERE 条件]</span><br></pre></td></tr></table></figure><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>数据查询语言，用来查询数据库表中的记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#编写顺序：</span><br><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名列表</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br><span class="line"></span><br><span class="line">#执行顺序：FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;SELECT-&gt;ORDER BY-&gt;LIMIT</span><br><span class="line"></span><br><span class="line">#基本查询</span><br><span class="line">#查询多个字段</span><br><span class="line">SELECT 字段1,字段2,字段三... FROM 表名;</span><br><span class="line">SELECT * FROM 表名;</span><br><span class="line">#设置别名</span><br><span class="line">SELECT 字段1[AS 别名1],字段2[AS 别名2]... FROM 表名;</span><br><span class="line">#去除重复记录</span><br><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br><span class="line"></span><br><span class="line">#条件查询</span><br><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br><span class="line"></span><br><span class="line">#聚合函数</span><br><span class="line">SELECT 聚合函数(字段列表) FROM 表名;</span><br><span class="line"></span><br><span class="line">#分组查询</span><br><span class="line">/*WHERE与HAVING的区别</span><br><span class="line">1.执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤</span><br><span class="line">2.判断条件不同：where不能对聚合函数进行判断，而having可以</span><br><span class="line"></span><br><span class="line">执行顺序：where &gt; 聚合函数 &gt; having</span><br><span class="line">分组之后，出现的字段一般为聚合函数和分组字段，查询其他字段无任何意义</span><br><span class="line">*/</span><br><span class="line">SELECT 字段列表 FROM 表名 [WHERE 条件列表] GROUP BY 分组字段名 [HAVING 分组后过滤条件];</span><br><span class="line"></span><br><span class="line">#排序查询(多字段排序)</span><br><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;</span><br><span class="line">#排序方式：ASC 升序（默认值） DESC 降序</span><br><span class="line">#如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</span><br><span class="line"></span><br><span class="line">#分页查询</span><br><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</span><br><span class="line">/*</span><br><span class="line">1.起始索引从零开始，起始索引 = （查询页码 - 1）*每页显示记录数</span><br><span class="line">2.分页查询在不同数据库中有不同的实现，MySQL中为limit</span><br><span class="line">3.如果查询的是第一页数据，起始索引可以省略，直接简写成limit 10;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>条件列表：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">比较运算符</th><th style="text-align:center">功能</th><th style="text-align:center">逻辑运算符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td><td style="text-align:center">AND 或 &amp;&amp;</td><td style="text-align:center">并且</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td><td style="text-align:center">OR 或 \</td><td style="text-align:center">\</td><td></td><td>或者</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td><td style="text-align:center">NOT 或  !</td><td style="text-align:center">非，不是</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">大于等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">&lt;&gt;或!=</td><td style="text-align:center">不等于</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">BETWEEN…AND…</td><td style="text-align:center">在某个范围之内包括最小最大值 between后接最小值，and后接最大值</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">IN(…)</td><td style="text-align:center">在in之后的列表中的值，多选一</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">LIKE 占位符</td><td style="text-align:center">模糊匹配(_匹配单个字符，%匹配任意个字符)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">IS (NOT) NULL</td><td style="text-align:center">(不)是NULL</td><td style="text-align:center"></td></tr></tbody></table></div><p><strong>聚合函数</strong></p><p>将一列数据作为一个整体，进行纵向计算。</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table></div><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p>数据控制语言，用来创建数据库用户，控制数据库的访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#查询用户</span><br><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM user;</span><br><span class="line"></span><br><span class="line">#创建用户 主机名中使用%可以在任意主机访问数据库</span><br><span class="line">CREAT USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="line"></span><br><span class="line">#修改用户密码</span><br><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码&#x27;;</span><br><span class="line"></span><br><span class="line">#删除用户</span><br><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line"></span><br><span class="line">#权限操作</span><br><span class="line">#查询权限</span><br><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">#授予权限</span><br><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">#撤销权限</span><br><span class="line">REMOVE 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">/*</span><br><span class="line">1.多个权限之间用逗号分隔；</span><br><span class="line">2.授权时，数据库名和表名可以使用 * 进行通配，代表所有；</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ALL,ALL PRIVILEGES</td><td style="text-align:center">所有权限</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">查询数据</td></tr><tr><td style="text-align:center">INSERT</td><td style="text-align:center">插入数据</td></tr><tr><td style="text-align:center">UPDATE</td><td style="text-align:center">修改数据</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">删除数据</td></tr><tr><td style="text-align:center">ALTER</td><td style="text-align:center">修改表</td></tr><tr><td style="text-align:center">DROP</td><td style="text-align:center">删除数据库/表/视图</td></tr><tr><td style="text-align:center">CREATE</td><td style="text-align:center">创建数据库/表</td></tr></tbody></table></div><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>指一段可以直接被另一段程序调用的程序或代码</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 函数(参数);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CONCAT(S1,S2,…Sn)</td><td style="text-align:center">字符串拼接，将S1，S2，… Sn拼接成一个字符串</td></tr><tr><td style="text-align:center">LOWER(str)</td><td style="text-align:center">将字符串str全部转为小写</td></tr><tr><td style="text-align:center">UPPER(str)</td><td style="text-align:center">将字符串str全部转为大写</td></tr><tr><td style="text-align:center">LPAD(str,n,pad)</td><td style="text-align:center">左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度</td></tr><tr><td style="text-align:center">RPAD(str,n,pad)</td><td style="text-align:center">右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度</td></tr><tr><td style="text-align:center">TRIM(str)</td><td style="text-align:center">去掉字符串头部和尾部的空格</td></tr><tr><td style="text-align:center">SUBSTRING(str,start,len)</td><td style="text-align:center">返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table></div><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 函数(参数);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CEIL(x)</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">FLOOR(x)</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">MOD(x,y)</td><td style="text-align:center">返回x/y的模</td></tr><tr><td style="text-align:center">RAND()</td><td style="text-align:center">返回0~1内的随机数</td></tr><tr><td style="text-align:center">ROUND(x,y)</td><td style="text-align:center">求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table></div><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1 和 结束时间date2之间的天数</td></tr></tbody></table></div><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value , t , f)</td><td>如果value为true，则返回t，否则返回 f</td></tr><tr><td>FNULL(value1 , value2)</td><td>如果value1不为空，返回value1，否则 返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否 则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回 res1，… 否则返回default默认值</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#案例</span><br><span class="line">create table score(</span><br><span class="line">id int comment &#x27;ID&#x27;,</span><br><span class="line">name varchar(20) comment &#x27;姓名&#x27;,</span><br><span class="line">math int comment &#x27;数学&#x27;,</span><br><span class="line">english int comment &#x27;英语&#x27;,</span><br><span class="line">chinese int comment &#x27;语文&#x27;</span><br><span class="line">) comment &#x27;学员成绩表&#x27;;</span><br><span class="line">insert into score(id, name, math, english, chinese) </span><br><span class="line">VALUES </span><br><span class="line">(1, &#x27;Tom&#x27;, 67, 88, 95), </span><br><span class="line">(2, &#x27;Rose&#x27; , 23, 66, 90),</span><br><span class="line">(3, &#x27;Jack&#x27;, 56, 98, 76);</span><br><span class="line"></span><br><span class="line">#实现</span><br><span class="line">select</span><br><span class="line">id,</span><br><span class="line">name,</span><br><span class="line">(case when math &gt;= 85 then &#x27;优秀&#x27; when math &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end )&#x27;数学&#x27;,</span><br><span class="line">(case when english &gt;= 85 then &#x27;优秀&#x27; when english &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27;end ) &#x27;英语&#x27;,</span><br><span class="line">(case when chinese &gt;= 85 then &#x27;优秀&#x27; when chinese &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27;end ) &#x27;语文&#x27;</span><br><span class="line">from score;</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。 </p><p>目的：保证数据库中数据的正确、有效性和完整性。</p><div class="table-container"><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.16版本 之后)</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table></div><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><div class="table-container"><table><thead><tr><th>字段名</th><th>字段含义</th><th>字段类型</th><th>约束条件</th><th>约束关键字</th></tr></thead><tbody><tr><td>id</td><td>ID唯一标识</td><td>int</td><td>主键，并且自动增长</td><td>PRIMARY KEY, AUTO_INCREMENT</td></tr><tr><td>name</td><td>姓名</td><td>varchar(10)</td><td>不为空且唯一</td><td>NOY NULL, UNIQUE</td></tr><tr><td>age</td><td>年龄</td><td>int</td><td>大于零且小于等于一百二十</td><td>CHECK(age &gt; 0 &amp;&amp; age &lt;=120)</td></tr><tr><td>status</td><td>状态</td><td>char(1)</td><td>默认为1</td><td>DEFAULT ‘1’</td></tr><tr><td>gender</td><td>性别</td><td>char(1)</td><td>无</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#建表语句</span><br><span class="line">CREATE TABLE tb_user(</span><br><span class="line">id int AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;ID唯一标识&#x27;,</span><br><span class="line">name varchar(10) NOT NULL UNIQUE COMMENT &#x27;姓名&#x27; ,</span><br><span class="line">age int check (age &gt; 0 &amp;&amp; age &lt;= 120) COMMENT &#x27;年龄&#x27; ,</span><br><span class="line">status char(1) default &#x27;1&#x27; COMMENT &#x27;状态&#x27;,</span><br><span class="line">gender char(1) COMMENT &#x27;性别&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a><strong>外键约束</strong></h3><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p>子表（从表）：具有外键的表</p><p>父表（主表）：外键所关联的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#准备数据</span><br><span class="line">create table dept</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">    name varchar(50) not null comment &#x27;部门名称&#x27;</span><br><span class="line">) comment &#x27;部门表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO dept (id, name)</span><br><span class="line">VALUES (1, &#x27;研发部&#x27;),</span><br><span class="line">       (2, &#x27;市场部&#x27;),</span><br><span class="line">       (3, &#x27;财务部&#x27;),</span><br><span class="line">       (4, &#x27;销售部&#x27;),</span><br><span class="line">       (5, &#x27;总经办&#x27;);</span><br><span class="line"></span><br><span class="line">create table emp</span><br><span class="line">(</span><br><span class="line">    id        int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">    name      varchar(50) not null comment &#x27;姓名&#x27;,</span><br><span class="line">    age       int comment &#x27;年龄&#x27;,</span><br><span class="line">    job       varchar(20) comment &#x27;职位&#x27;,</span><br><span class="line">    salary    int comment &#x27;薪资&#x27;,</span><br><span class="line">    entrydate date comment &#x27;入职时间&#x27;,</span><br><span class="line">    managerid int comment &#x27;直属领导ID&#x27;,</span><br><span class="line">    dept_id   int comment &#x27;部门ID&#x27;</span><br><span class="line">) comment &#x27;员工表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)</span><br><span class="line">VALUES (1, &#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5),</span><br><span class="line">       (2, &#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),</span><br><span class="line">       (3, &#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1),</span><br><span class="line">       (4, &#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),</span><br><span class="line">       (5, &#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1),</span><br><span class="line">       (6, &#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1);</span><br><span class="line">       </span><br><span class="line">#添加外键约束</span><br><span class="line">alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="添加外键"><a href="#添加外键" class="headerlink" title="添加外键"></a><strong>添加外键</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">...</span><br><span class="line">[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#方法二</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;</span><br></pre></td></tr></table></figure><h4 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a><strong>删除外键</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br></pre></td></tr></table></figure><h4 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h4><p>添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行 为有以下几种:</p><div class="table-container"><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES </span><br><span class="line">主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h4 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h4><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><p>​    <strong>1.一对多(多对一)</strong> </p><p>​        案例: 部门 与 员工的关系 </p><p>​        关系: 一个部门对应多个员工，一个员工对应一个部门 </p><p>​        实现: 在多的一方建立外键，指向一的一方的主键</p><p>​    <strong>2.多对多</strong> </p><p>​        案例: 学生 与 课程的关系 </p><p>​        关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择 </p><p>​        实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">create table student</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    name varchar(10) comment &#x27;姓名&#x27;,</span><br><span class="line">    no   varchar(10) comment &#x27;学号&#x27;</span><br><span class="line">) comment &#x27;学生表&#x27;;</span><br><span class="line"></span><br><span class="line">insert into student</span><br><span class="line">values (null, &#x27;黛绮丝&#x27;, &#x27;2000100101&#x27;),</span><br><span class="line">       (null, &#x27;谢逊&#x27;,</span><br><span class="line">        &#x27;2000100102&#x27;),</span><br><span class="line">       (null, &#x27;殷天正&#x27;, &#x27;2000100103&#x27;),</span><br><span class="line">       (null, &#x27;韦一笑&#x27;, &#x27;2000100104&#x27;);</span><br><span class="line"></span><br><span class="line">create table course</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    name varchar(10) comment &#x27;课程名称&#x27;</span><br><span class="line">) comment &#x27;课程表&#x27;;</span><br><span class="line">insert into course</span><br><span class="line">values (null, &#x27;Java&#x27;),</span><br><span class="line">       (null, &#x27;PHP&#x27;),</span><br><span class="line">       (null, &#x27;MySQL&#x27;),</span><br><span class="line">       (null, &#x27;Hadoop&#x27;);</span><br><span class="line"></span><br><span class="line">create table student_course</span><br><span class="line">(</span><br><span class="line">    id        int auto_increment comment &#x27;主键&#x27; primary key,</span><br><span class="line">    studentid int not null comment &#x27;学生ID&#x27;,</span><br><span class="line">    courseid  int not null comment &#x27;课程ID&#x27;,</span><br><span class="line">    constraint fk_courseid foreign key (courseid) references course (id),</span><br><span class="line">    constraint fk_studentid foreign key (studentid) references student (id)</span><br><span class="line">) comment &#x27;学生课程中间表&#x27;;</span><br><span class="line"></span><br><span class="line">insert into student_course</span><br><span class="line">values (null, 1, 1),</span><br><span class="line">       (null, 1, 2),</span><br><span class="line">       (null, 1, 3),</span><br><span class="line">       (null, 2, 2),</span><br><span class="line">       (null, 2, 3),</span><br><span class="line">       (null, 3, 4);</span><br></pre></td></tr></table></figure><p>​    <strong>3.一对一</strong></p><p>​        案例: 用户 与 用户详情的关系 </p><p>​        关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另 一张表中，以提升操作效率 </p><p>​        实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的<strong>(UNIQUE)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">create table tb_user</span><br><span class="line">(</span><br><span class="line">    id     int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    name   varchar(10) comment &#x27;姓名&#x27;,</span><br><span class="line">    age    int comment &#x27;年龄&#x27;,</span><br><span class="line">    gender char(1) comment &#x27;1: 男 , 2: 女&#x27;,</span><br><span class="line">    phone  char(11) comment &#x27;手机号&#x27;</span><br><span class="line">) comment &#x27;用户基本信息表&#x27;;</span><br><span class="line"></span><br><span class="line">create table tb_user_edu</span><br><span class="line">(</span><br><span class="line">    id            int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    degree        varchar(20) comment &#x27;学历&#x27;,</span><br><span class="line">    major         varchar(50) comment &#x27;专业&#x27;,</span><br><span class="line">    primaryschool varchar(50) comment &#x27;小学&#x27;,</span><br><span class="line">    middleschool  varchar(50) comment &#x27;中学&#x27;,</span><br><span class="line">    university    varchar(50) comment &#x27;大学&#x27;,</span><br><span class="line">    userid        int unique comment &#x27;用户ID&#x27;,</span><br><span class="line">    constraint fk_userid foreign key (userid) references tb_user (id)</span><br><span class="line">) comment &#x27;用户教育信息表&#x27;;</span><br><span class="line"></span><br><span class="line">insert into tb_user(id, name, age, gender, phone)</span><br><span class="line"></span><br><span class="line">values (null, &#x27;黄渤&#x27;, 45, &#x27;1&#x27;, &#x27;18800001111&#x27;),</span><br><span class="line">       (null, &#x27;冰冰&#x27;, 35, &#x27;2&#x27;, &#x27;18800002222&#x27;),</span><br><span class="line">       (null, &#x27;码云&#x27;, 55, &#x27;1&#x27;, &#x27;18800008888&#x27;),</span><br><span class="line">       (null, &#x27;李彦宏&#x27;, 50, &#x27;1&#x27;, &#x27;18800009999&#x27;);</span><br><span class="line"></span><br><span class="line">insert into tb_user_edu(id, degree, major, primaryschool, middleschool,</span><br><span class="line">                        university, userid)</span><br><span class="line"></span><br><span class="line">values (null, &#x27;本科&#x27;, &#x27;舞蹈&#x27;, &#x27;静安区第一小学&#x27;, &#x27;静安区第一中学&#x27;, &#x27;北京舞蹈学院&#x27;, 1),</span><br><span class="line">       (null, &#x27;硕士&#x27;, &#x27;表演&#x27;, &#x27;朝阳区第一小学&#x27;, &#x27;朝阳区第一中学&#x27;, &#x27;北京电影学院&#x27;, 2),</span><br><span class="line">       (null, &#x27;本科&#x27;, &#x27;英语&#x27;, &#x27;杭州市第一小学&#x27;, &#x27;杭州市第一中学&#x27;, &#x27;杭州师范大学&#x27;, 3),</span><br><span class="line">       (null, &#x27;本科&#x27;, &#x27;应用数学&#x27;, &#x27;阳泉第一小学&#x27;, &#x27;阳泉区第一中学&#x27;, &#x27;清华大学&#x27;, 4);</span><br></pre></td></tr></table></figure><h4 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h4><p><strong>1.准备数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">-- 创建dept表，并插入数据</span><br><span class="line">create table dept</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">    name varchar(50) not null comment &#x27;部门名称&#x27;</span><br><span class="line">) comment &#x27;部门表&#x27;;</span><br><span class="line">INSERT INTO dept (id, name)</span><br><span class="line">VALUES (1, &#x27;研发部&#x27;),</span><br><span class="line">       (2, &#x27;市场部&#x27;),</span><br><span class="line">       (3, &#x27;财务部&#x27;),</span><br><span class="line">       (4, &#x27;销售部&#x27;),</span><br><span class="line">       (5, &#x27;总经办&#x27;),</span><br><span class="line">       (6, &#x27;人事部&#x27;);</span><br><span class="line">-- 创建emp表，并插入数据</span><br><span class="line">create table emp</span><br><span class="line">(</span><br><span class="line">    id        int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">    name      varchar(50) not null comment &#x27;姓名&#x27;,</span><br><span class="line">    age       int comment &#x27;年龄&#x27;,</span><br><span class="line">    job       varchar(20) comment &#x27;职位&#x27;,</span><br><span class="line">    salary    int comment &#x27;薪资&#x27;,</span><br><span class="line">    entrydate date comment &#x27;入职时间&#x27;,</span><br><span class="line">    managerid int comment &#x27;直属领导ID&#x27;,</span><br><span class="line">    dept_id   int comment &#x27;部门ID&#x27;</span><br><span class="line">) comment &#x27;员工表&#x27;;</span><br><span class="line">-- 添加外键</span><br><span class="line">alter table emp</span><br><span class="line">    add constraint fk_emp_dept_id foreign key (dept_id) references</span><br><span class="line">        dept (id);</span><br><span class="line"></span><br><span class="line">INSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)</span><br><span class="line">VALUES (1, &#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5),</span><br><span class="line">       (2, &#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),</span><br><span class="line">       (3, &#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1),</span><br><span class="line">       (4, &#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),</span><br><span class="line">       (5, &#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1),</span><br><span class="line">       (6, &#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1),</span><br><span class="line">       (7, &#x27;灭绝&#x27;, 60, &#x27;财务总监&#x27;, 8500, &#x27;2002-09-12&#x27;, 1, 3),</span><br><span class="line">       (8, &#x27;周芷若&#x27;, 19, &#x27;会计&#x27;, 4800, &#x27;2006-06-02&#x27;, 7, 3),</span><br><span class="line">       (9, &#x27;丁敏君&#x27;, 23, &#x27;出纳&#x27;, 5250, &#x27;2009-05-13&#x27;, 7, 3),</span><br><span class="line">       (10, &#x27;赵敏&#x27;, 20, &#x27;市场部总监&#x27;, 12500, &#x27;2004-10-12&#x27;, 1, 2),</span><br><span class="line">       (11, &#x27;鹿杖客&#x27;, 56, &#x27;职员&#x27;, 3750, &#x27;2006-10-03&#x27;, 10, 2),</span><br><span class="line">       (12, &#x27;鹤笔翁&#x27;, 19, &#x27;职员&#x27;, 3750, &#x27;2007-05-09&#x27;, 10, 2),</span><br><span class="line">       (13, &#x27;方东白&#x27;, 19, &#x27;职员&#x27;, 5500, &#x27;2009-02-12&#x27;, 10, 2),</span><br><span class="line">       (14, &#x27;张三丰&#x27;, 88, &#x27;销售总监&#x27;, 14000, &#x27;2004-10-12&#x27;, 1, 4),</span><br><span class="line">       (15, &#x27;俞莲舟&#x27;, 38, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),</span><br><span class="line">       (16, &#x27;宋远桥&#x27;, 40, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),</span><br><span class="line">       (17, &#x27;陈友谅&#x27;, 42, null, 2000, &#x27;2011-10-12&#x27;, 1, null);</span><br></pre></td></tr></table></figure><p><strong>2.语法</strong></p><p>多表查询就是指从多张表中查询数据。</p><p>原来查询单表数据，执行的SQL形式为：select * from emp; 那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，</p><p>如： select * from emp , dept ; </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*笛卡尔积</span><br><span class="line">1,金庸,66,总裁,20000,2000-01-01,,5,6,人事部</span><br><span class="line">1,金庸,66,总裁,20000,2000-01-01,,5,5,总经办</span><br><span class="line">1,金庸,66,总裁,20000,2000-01-01,,5,4,销售部</span><br><span class="line">1,金庸,66,总裁,20000,2000-01-01,,5,3,财务部</span><br><span class="line">1,金庸,66,总裁,20000,2000-01-01,,5,2,市场部</span><br><span class="line">1,金庸,66,总裁,20000,2000-01-01,,5,1,研发部</span><br><span class="line"></span><br><span class="line">17,陈友谅,42,,2000,2011-10-12,1,,6,人事部</span><br><span class="line">17,陈友谅,42,,2000,2011-10-12,1,,5,总经办</span><br><span class="line">17,陈友谅,42,,2000,2011-10-12,1,,4,销售部</span><br><span class="line">17,陈友谅,42,,2000,2011-10-12,1,,3,财务部</span><br><span class="line">17,陈友谅,42,,2000,2011-10-12,1,,2,市场部</span><br><span class="line">17,陈友谅,42,,2000,2011-10-12,1,,1,研发部</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><strong>而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</strong></p><p>在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp , dept where emp.dept_id = dept.id;</span><br></pre></td></tr></table></figure><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>相当于查询A、B交集部分数据</p><p>内连接的语法分为两种: 隐式内连接、显式内连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#隐式内连接</span><br><span class="line">SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</span><br><span class="line"></span><br><span class="line">#显式内连接</span><br><span class="line">SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>左外连接：查询左表所有数据，以及两张表交集部分数据 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br></pre></td></tr></table></figure><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</span><br></pre></td></tr></table></figure><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>当前表与自身的连接查询，<strong>自连接必须使用表别名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</span><br></pre></td></tr></table></figure><p>而对于自连接查询，可以是内连接查询，也可以是外连接查询。</p><p><strong>相当于把一张表看成两张！</strong></p><h4 id="联合查询-union-union-all"><a href="#联合查询-union-union-all" class="headerlink" title="联合查询 -union, union all"></a><strong>联合查询 -union, union all</strong></h4><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ...</span><br><span class="line">UNION [ ALL ]</span><br><span class="line">SELECT 字段列表 FROM 表B ....;</span><br></pre></td></tr></table></figure><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。 </p><p>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 )</span><br></pre></td></tr></table></figure><p><strong>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。</strong></p><p>根据子查询结果不同，分为： </p><p><strong>A. 标量子查询（子查询结果为单个值）</strong></p><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 </p><p>常用的操作符：=  &lt;&gt;  &gt;  &gt;=  &lt;  &lt;= </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询 &quot;销售部&quot; 的所有员工信息</span><br><span class="line">select * from emp where dept_id = (select id from dept where name = &#x27;销售部&#x27;);</span><br><span class="line"></span><br><span class="line"># 查询在 &quot;方东白&quot; 入职之后的员工信息</span><br><span class="line">select * from emp where entrydate &gt; (select entrydate from emp where name = &#x27;方东白&#x27;);</span><br></pre></td></tr></table></figure><p><strong>B. 列子查询(子查询结果为一列)</strong> </p><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><div class="table-container"><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查询 &quot;销售部&quot; 和 &quot;市场部&quot; 的所有员工信息</span><br><span class="line">select * from emp where dept_id in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br><span class="line"></span><br><span class="line"># 查询比 财务部 所有人工资都高的员工信息</span><br><span class="line">select * from emp where salary &gt; all ( select salary from emp where dept_id = (select id from dept where name = &#x27;财务部&#x27;));</span><br><span class="line"></span><br><span class="line"># 查询比研发部其中任意一人工资高的员工信息</span><br><span class="line">select * from emp where salary &gt; any ( select salary from emp where dept_id = (select id from dept where name = &#x27;研发部&#x27;) );</span><br></pre></td></tr></table></figure><p><strong>C. 行子查询(子查询结果为一行)</strong> </p><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。 </p><p>常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询与 &quot;张无忌&quot; 的薪资及直属领导相同的员工信息 </span><br><span class="line">select * from emp where (salary,managerid) = (select salary,managerid from emp where name = &#x27;张无忌&#x27;);</span><br></pre></td></tr></table></figure><p><strong>D. 表子查询(子查询结果为多行多列)</strong> </p><p>子查询返回的结果是多行多列，这种子查询称为表子查询。</p><p>相当于返回的是一张表，常放于from后</p><p> 常用的操作符：IN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询与 &quot;鹿杖客&quot; , &quot;宋远桥&quot; 的职位和薪资相同的员工信息</span><br><span class="line">select * from emp where (job,salary) in (select job,salary from emp where name = &#x27;鹿杖客&#x27; or name = &#x27;宋远桥&#x27;);</span><br><span class="line"></span><br><span class="line"># 查询入职日期是 &quot;2006-01-01&quot; 之后的员工信息 , 及其部门信息</span><br><span class="line">select e.*,d.* from (select * from emp where entrydate &gt; &#x27;2006-01-01&#x27;) e left outer join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure><p>根据子查询位置，分为： </p><p><strong>A. WHERE之后</strong> </p><p><strong>B. FROM之后</strong> </p><p><strong>C. SELECT之后</strong></p><h4 id="多表查询案例"><a href="#多表查询案例" class="headerlink" title="多表查询案例"></a>多表查询案例</h4><p><strong>数据准备：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table salgrade(</span><br><span class="line">grade int,</span><br><span class="line">losal int,</span><br><span class="line">hisal int</span><br><span class="line">) comment &#x27;薪资等级表&#x27;;</span><br><span class="line"></span><br><span class="line">insert into salgrade values (1,0,3000);</span><br><span class="line">insert into salgrade values (2,3001,5000);</span><br><span class="line">insert into salgrade values (3,5001,8000);</span><br><span class="line">insert into salgrade values (4,8001,10000);</span><br><span class="line">insert into salgrade values (5,10001,15000);</span><br><span class="line">insert into salgrade values (6,15001,20000);</span><br><span class="line">insert into salgrade values (7,20001,25000);</span><br><span class="line">insert into salgrade values (8,25001,30000);</span><br></pre></td></tr></table></figure><p>在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，</p><p>而这里主要涉 及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#查询员工的姓名、年龄、职位、部门信息 （隐式内连接）</span><br><span class="line">select emp.name,age,job,dept.name from emp,dept where dept_id = dept.id order by emp.id asc;</span><br><span class="line"></span><br><span class="line">#查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）</span><br><span class="line">select e.name,age,job,d.name from emp e inner  join dept d on e.dept_id = d.id where e.age &lt; 30 order by e.id asc;</span><br><span class="line"></span><br><span class="line">#查询所有员工的部门ID、部门名称 distinct-&gt;去重</span><br><span class="line">select distinct d.id , d.name from emp e , dept d where e.dept_id = d.id;</span><br><span class="line"></span><br><span class="line">#查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)</span><br><span class="line">select e.*,d.name from emp e left join dept d on d.id = e.dept_id where e.age &gt; 40;</span><br><span class="line"></span><br><span class="line">#查询所有员工的工资等级</span><br><span class="line">select e.name,s.grade from emp e,salgrade s where e.salary &gt;= s.losal and e.salary &lt;= s.hisal;</span><br><span class="line"></span><br><span class="line">#查询 &quot;研发部&quot; 所有员工的信息及 工资等级</span><br><span class="line">select e.*,s.grade from emp e,salgrade s,dept d where e.salary &gt;= s.losal and e.salary &lt;= s.hisal and e.dept_id = d.id and d.name = &#x27;研发部&#x27; ;</span><br><span class="line"></span><br><span class="line">#查询 &quot;研发部&quot; 员工的平均工资</span><br><span class="line">select avg(e.salary) from emp e,dept d where dept_id = d.id &amp;&amp; d.name = &#x27;研发部&#x27; ;</span><br><span class="line"></span><br><span class="line">#查询工资比 &quot;灭绝&quot; 高的员工信息。</span><br><span class="line">select * from emp e where e.salary &gt; (select salary from emp where name = &#x27;灭绝&#x27;);</span><br><span class="line"></span><br><span class="line">#查询比平均薪资高的员工信息</span><br><span class="line">select * from emp where salary &gt; (select avg(salary) from emp);</span><br><span class="line"></span><br><span class="line">#查询低于本部门平均工资的员工信息</span><br><span class="line">select * from emp e2 where e2.salary &lt; ( select avg(e1.salary) from emp e1 where e1.dept_id = e2.dept_id );</span><br><span class="line"></span><br><span class="line">#查询所有的部门信息, 并统计部门的员工人数</span><br><span class="line">select d.*,(select count(*) from emp where dept_id = d.id)from dept d;</span><br><span class="line"></span><br><span class="line">#查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称</span><br><span class="line">select s.name , s.no , c.name from student s , student_course sc , course c where s.id = sc.studentid and sc.courseid = c.id ;</span><br></pre></td></tr></table></figure><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="数据库设计的范式"><a href="#数据库设计的范式" class="headerlink" title="数据库设计的范式"></a>数据库设计的范式</h3><ul><li><p>概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。<br>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p></li><li><p>分类：</p><ol><li>第一范式（1NF）：每一列都是不可分割的原子数据项</li><li><p>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）</p><ul><li>几个概念：<ol><li>函数依赖：A—&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A<br>例如：学号—&gt;姓名。  （学号，课程名称） —&gt; 分数</li><li>完全函数依赖：A—&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。<br>例如：（学号，课程名称） —&gt; 分数</li><li>部分函数依赖：A—&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。<br>例如：（学号，课程名称） — &gt; 姓名</li><li>传递函数依赖：A—&gt;B, B — &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A<br>例如：学号—&gt;系名，系名—&gt;系主任</li><li>码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码<br>例如：该表中码为：（学号，课程名称）<ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除过码属性组的属性</li></ul></li></ol></li></ul></li><li><p>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</p></li></ol></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h4><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作<strong>要么同时成功，要么同时失败</strong>。 </p><p>就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。</p><p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :</p><p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。</p><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>数据准备：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists account;</span><br><span class="line"></span><br><span class="line">create table account(</span><br><span class="line">id int primary key AUTO_INCREMENT comment &#x27;ID&#x27;,</span><br><span class="line">name varchar(10) comment &#x27;姓名&#x27;,</span><br><span class="line">money double(10,2) comment &#x27;余额&#x27;</span><br><span class="line">) comment &#x27;账户表&#x27;;</span><br><span class="line"></span><br><span class="line">insert into account(name, money) VALUES (&#x27;张三&#x27;,2000), (&#x27;李四&#x27;,2000);</span><br><span class="line"></span><br><span class="line"># 正常情况</span><br><span class="line">-- 1. 查询张三余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">-- 2. 张三的余额减少1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">-- 3. 李四的余额增加1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line"># 异常情况</span><br><span class="line">-- 1. 查询张三余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">-- 2. 张三的余额减少1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">出错了....</span><br><span class="line">-- 3. 李四的余额增加1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br></pre></td></tr></table></figure><h5 id="事务操作方法一"><a href="#事务操作方法一" class="headerlink" title="事务操作方法一"></a>事务操作方法一</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#查看/设置事务提交方式</span><br><span class="line">SELECT @@autocommit ;</span><br><span class="line">SET @@autocommit = 0 ;</span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">#回滚事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">#注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提</span><br><span class="line">#交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。</span><br></pre></td></tr></table></figure><h5 id="事务操作方法二"><a href="#事务操作方法二" class="headerlink" title="事务操作方法二"></a>事务操作方法二</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">START TRANSACTION 或 BEGIN ;</span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">#回滚事务</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">start transaction</span><br><span class="line">-- 1. 查询张三余额</span><br><span class="line">select * from account where name = &#x27;张三&#x27;;</span><br><span class="line">-- 2. 张三的余额减少1000</span><br><span class="line">update account set money = money - 1000 where name = &#x27;张三&#x27;;</span><br><span class="line">-- 3. 李四的余额增加1000</span><br><span class="line">update account set money = money + 1000 where name = &#x27;李四&#x27;;</span><br><span class="line">-- 如果正常执行完毕, 则提交事务</span><br><span class="line">commit;</span><br><span class="line">-- 如果执行过程中报错, 则回滚事务</span><br><span class="line">-- rollback;</span><br></pre></td></tr></table></figure><h4 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h4><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </p><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 </p><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。 </p><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 </p><p>上述就是事务的四大特性，简称<strong>ACID</strong>。</p><h4 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h4><p><strong>赃读</strong>：一个事务读到另外一个事务还没有提交的数据。</p><p><strong>不可重复读</strong>：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p><strong>幻读</strong>：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。</p><h4 id="事务隔离级别（底层原理未搞清楚！！）"><a href="#事务隔离级别（底层原理未搞清楚！！）" class="headerlink" title="事务隔离级别（底层原理未搞清楚！！）"></a>事务隔离级别（底层原理未搞清楚！！）</h4><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看事务隔离级别</span><br><span class="line"></span><br><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br><span class="line">#设置事务隔离级别 SESSION-&gt;当前会话窗口有效 GLOBAL-&gt;全部会话窗口都有效</span><br><span class="line">SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123; READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;</span><br></pre></td></tr></table></figure><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql&quot;&gt;&lt;a href=&quot;#Mysql&quot; class=&quot;headerlink&quot; title=&quot;Mysql&quot;&gt;&lt;/a&gt;Mysql&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;SQL&lt;/strong&gt;——操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://blog.hiles.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket笔记</title>
    <link href="https://blog.hiles.cn/posts/9839fadc.html"/>
    <id>https://blog.hiles.cn/posts/9839fadc.html</id>
    <published>2022-09-25T12:07:17.000Z</published>
    <updated>2022-09-25T13:48:26.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h1><p>Http协议有缺陷，通信只能由客户端发起，做不到服务器主动向客户端推送信息。<br><img src="https://img.hiles.cn/bg2017051507.jpg" alt="image"><br>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用轮询：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。<span class="bubble-content">轮询</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">客户端在固定的时间间隔下不停地向服务端发送请求，查看服务端是否有新的数据，若服务端有新的数据，则返回给客户端，若是服务端没有新的数据，则返回一个空的JSON或者XML文档，轮询对于开发者来说实现方便，但弊端明显：客户端每次都要建立新的HTTP请求，服务端要处理大量的无效请求，在高并发的情景下会严重拖慢服务端的运行效率，同时服务端的资源被极大地浪费了。</span></span>的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。<br>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。<br><img src="https://img.hiles.cn/bg2017051502.png" alt="image"><br>其他特点：</p><ul><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li></ul><p>使用时机：</p><ul><li>WebSockets可以使网页动态和交互。但是，在许多情况下，Ajax和HTTP流和/或长轮询的组合可以提供简单有效的解决方案。</li><li>例如，新闻，邮件和社交订阅源需要动态更新，但每隔几分钟就可以完全正常更新。</li><li>另一方面，协作，游戏和财务应用程序需要更接近实时。仅延迟不是决定因素。如果消息量相对较低（例如，监视网络故障），则HTTP流式传输或轮询可以提供有效的解决方案。它是低延迟，高频率和高容量的组合，是使用WebSocket的最佳选择。</li></ul><h1 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h1><p>Spring Framework提供了一个WebSocket API，可用于编写处理WebSocket消息的客户端和服务器端应用程序。</p><h2 id="WebSocketHandler"><a href="#WebSocketHandler" class="headerlink" title="WebSocketHandler"></a>WebSocketHandler</h2><p>创建的WebSocket服务器是为实现简单<span class='p cyan'>WebSocketHandler</span>或更可能要么延长<span class='p cyan'>TextWebSocketHandler</span>或<span class='p cyan'>BinaryWebSocketHandler</span><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="WebSocket握手"><a href="#WebSocket握手" class="headerlink" title="WebSocket握手"></a>WebSocket握手</h2><p>通过<span class='p green'>HandshakeInterceptor</span>，暴露握手方法的“之前”与“之后”，可以自定义初始的HTTP WebSocket握手请求。这样的拦截器可用于阻止握手或使任何属性可用于<span class='p blue'>WebSocketSession</span>。例如，有一个内置拦截器，用于将HTTP会话属性传递给WebSocket会话：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.http.HttpUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.HandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 握手前</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wsHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attributes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 握手后</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wsHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">//···</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="WebSocket-Config"><a href="#WebSocket-Config" class="headerlink" title="WebSocket Config"></a>WebSocket Config</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    MyHandler myHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    MyInterceptor myInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(myHandler, <span class="string">&quot;/myHandler&quot;</span>)</span><br><span class="line">            .addInterceptor(myInterceptor);</span><br><span class="line">            .setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现  WebSocketConfigurer 类并覆盖相应的方法进行 websocket 的配置。我们主要覆盖  registerWebSocketHandlers 这个方法。通过向  WebSocketHandlerRegistry 设置不同参数来进行配置。其中 addHandler方法添加我们上面的写的 ws 的   handler 处理类，第二个参数是你暴露出的 ws 路径.addInterceptors 添加我们写的握手过滤器。setAllowedOrigins(“*”)这个是关闭跨域校验，方便本地调试，线上推荐打开。</p>]]></content>
    
    
    <summary type="html">WebSocket笔记</summary>
    
    
    
    <category term="后台成长历程" scheme="https://blog.hiles.cn/categories/%E5%90%8E%E5%8F%B0%E6%88%90%E9%95%BF%E5%8E%86%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://blog.hiles.cn/tags/java/"/>
    
    <category term="WebSocket" scheme="https://blog.hiles.cn/tags/WebSocket/"/>
    
    <category term="Spring" scheme="https://blog.hiles.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>夜月集</title>
    <link href="https://blog.hiles.cn/posts/5c9c1785.html"/>
    <id>https://blog.hiles.cn/posts/5c9c1785.html</id>
    <published>2022-09-10T07:17:07.000Z</published>
    <updated>2022-09-10T08:12:46.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闲暇时间写的小诗"><a href="#闲暇时间写的小诗" class="headerlink" title="闲暇时间写的小诗"></a>闲暇时间写的小诗</h1><h2 id="第一首"><a href="#第一首" class="headerlink" title="第一首"></a>第一首</h2><p class='p cyan'>在高中，一个舒服的午睡中，做了个梦，然后就自然而然地写出了下面的这首~</p><div class='poem'><div class='poem-title'>无题</div><div class='poem-author'>昼阳</div><p>斜风细雨映琉璃，<br>茉莉香缕小径西。<br>桥畔绮琴轻蝶舞，<br>梨窝浅笑百莺啼。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;闲暇时间写的小诗&quot;&gt;&lt;a href=&quot;#闲暇时间写的小诗&quot; class=&quot;headerlink&quot; title=&quot;闲暇时间写的小诗&quot;&gt;&lt;/a&gt;闲暇时间写的小诗&lt;/h1&gt;&lt;h2 id=&quot;第一首&quot;&gt;&lt;a href=&quot;#第一首&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="诗词歌赋" scheme="https://blog.hiles.cn/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"/>
    
    
    <category term="诗集" scheme="https://blog.hiles.cn/tags/%E8%AF%97%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础</title>
    <link href="https://blog.hiles.cn/posts/d607e27b.html"/>
    <id>https://blog.hiles.cn/posts/d607e27b.html</id>
    <published>2022-09-08T13:22:32.000Z</published>
    <updated>2022-09-10T09:35:39.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><span class='p blue'>Spring基础</span></h1><h2 id="Spring系统架构"><a href="#Spring系统架构" class="headerlink" title="Spring系统架构"></a>Spring系统架构</h2><ul><li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p></li><li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整<br><img src="http://img.hiles.cn/image-20210729172153796.png" alt="image-20210729172153796"></p></li><li>Spring Framework 4的版本的系统结构图<br><img src="http://img.hiles.cn/1629720945720.png" alt="1629720945720"></li></ul><p>(1)核心层</p><ul><li>Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul><p>(2)AOP层</p><ul><li>AOP:面向切面编程，它依赖核心层容器，目的是==在不改变原有代码的前提下对其进行功能增强==</li><li>Aspects:AOP是思想,Aspects是对AOP思想的具体实现</li></ul><p>(3)数据层</p><ul><li>Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul><p>(4)Web层</p><ul><li>SpringMVC</li></ul><p>(5)Test层</p><ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul><h2 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h2><h3 id="IOC、IOC容器、Bean、DI"><a href="#IOC、IOC容器、Bean、DI" class="headerlink" title="IOC、IOC容器、Bean、DI"></a>IOC、IOC容器、Bean、DI</h3><p>1.IOC（Inversion of Control）控制反转</p>]]></content>
    
    
    <summary type="html">Spring基础</summary>
    
    
    
    <category term="后台成长历程" scheme="https://blog.hiles.cn/categories/%E5%90%8E%E5%8F%B0%E6%88%90%E9%95%BF%E5%8E%86%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://blog.hiles.cn/tags/java/"/>
    
    <category term="springboot" scheme="https://blog.hiles.cn/tags/springboot/"/>
    
    <category term="redis" scheme="https://blog.hiles.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Redis</title>
    <link href="https://blog.hiles.cn/posts/4ebad2d4.html"/>
    <id>https://blog.hiles.cn/posts/4ebad2d4.html</id>
    <published>2022-09-07T13:44:11.000Z</published>
    <updated>2022-09-10T09:36:18.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><h2 id="1-现在pom-xml中导入Redis项目依赖"><a href="#1-现在pom-xml中导入Redis项目依赖" class="headerlink" title="1.现在pom.xml中导入Redis项目依赖"></a>1.现在pom.xml中导入Redis项目依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  redis  --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-配置application配置文件"><a href="#2-配置application配置文件" class="headerlink" title="2.配置application配置文件"></a>2.配置application配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    redis:</span><br><span class="line">    database: <span class="number">0</span></span><br><span class="line">    # Redis服务器Ip地址</span><br><span class="line">    host: </span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    # 密码 默认为空</span><br><span class="line">    password: </span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: <span class="number">200</span></span><br><span class="line">        # 连接池最大阻塞等待时间（使用负值表示没有限制） 表示连接池的链接拿完了 现在去申请需要等待的时间</span><br><span class="line">        max-wait: -<span class="number">1</span></span><br><span class="line">        # 连接池中的最大空闲连接</span><br><span class="line">        max-idle: <span class="number">10</span></span><br><span class="line">        # 连接池中的最小空闲连接</span><br><span class="line">        min-idle: <span class="number">0</span></span><br><span class="line">    # 连接超时时间（毫秒） 去链接redis服务端</span><br><span class="line">    timeout: <span class="number">6000</span></span><br></pre></td></tr></table></figure><h2 id="3-开放端口"><a href="#3-开放端口" class="headerlink" title="3.开放端口"></a>3.开放端口</h2><h4 id="1-去自己的云服务器官网修改自己的服务器的安全组添加6379端口"><a href="#1-去自己的云服务器官网修改自己的服务器的安全组添加6379端口" class="headerlink" title="1. 去自己的云服务器官网修改自己的服务器的安全组添加6379端口"></a>1. 去自己的云服务器官网修改自己的服务器的安全组添加6379端口</h4><h4 id="2-在linux服务器编辑redis-conf配置文件，取消本地绑定，开启远程访问"><a href="#2-在linux服务器编辑redis-conf配置文件，取消本地绑定，开启远程访问" class="headerlink" title="2. 在linux服务器编辑redis.conf配置文件，取消本地绑定，开启远程访问"></a>2. 在linux服务器编辑redis.conf配置文件，取消本地绑定，开启远程访问</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到配置文件redis.conf，修改配置文件 输入whereis redis.conf可以找到文件位置</span></span><br><span class="line"><span class="comment">//开启远程连接（注释掉代表允许所有人访问）</span></span><br><span class="line">#bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -::<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启远程连接（允许所有人访问，由yes修改为no）</span></span><br><span class="line"><span class="keyword">protected</span>-mode no</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-编写RedisUtils工具类"><a href="#4-编写RedisUtils工具类" class="headerlink" title="4.编写RedisUtils工具类"></a>4.编写RedisUtils工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------key 相关操作---------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要删除的 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys 要删除的 键 的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Collection&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        redisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 判断该 键 是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在返回 true, 不存在返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     要设置的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功返回 true, 设置失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置在什么时间过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  要设置的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> date 过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功返回 true, 设置失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">expireAt</span><span class="params">(String key, Date date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expireAt(key, date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找匹配的 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 匹配字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 满足匹配条件的 键 的 Set 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">keys</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前数据库的 key 移动到给定的数据库 db 当中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     要移动的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbIndex 要移动到的 db 的序号, 从 0 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移动成功返回 true, 移动失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">move</span><span class="params">(String key, <span class="type">int</span> dbIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.move(key, dbIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 key 的过期时间，key 将持久保持</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要移除过期时间的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除成功返回 true, 并且该 key 将持久存在, 移除失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">persist</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.persist(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 key 的剩余的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  要查询剩余过期时间的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间的单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 剩余的过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getExpire</span><span class="params">(String key, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 key 的剩余的过期时间, 默认时间单位: 秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要查询剩余过期时间的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 剩余的过期时间, 单位: 秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从当前数据库中随机返回一个 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 随机获取的 键 的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">randomKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.randomKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改 key 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldKey 修改前的 键 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newKey 修改后的 键 的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rename</span><span class="params">(String oldKey, String newKey)</span> &#123;</span><br><span class="line">        redisTemplate.rename(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅当 newKey 不存在时，将 oldKey 改名为 newKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldKey 修改前的 键 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newKey 修改后的 键 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改成功返回 true, 修改失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">renameIfAbsent</span><span class="params">(String oldKey, String newKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.renameIfAbsent(oldKey, newKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 key 所储存的值的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要查询类型的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key 的数据类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> DataType <span class="title function_">type</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.type(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------string 相关操作---------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置指定 key 的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要设置的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要设置的 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定 key 的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 键 对应的 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 key 的 字符串值 中指定位置的 子字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要获取值的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置, 最小值: 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置, 最大值: 字符串 - 1, 若为 -1 则是获取整个字符串值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定 键 的 字符串值 的 子字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定 key 的值设为 value ，并返回 key 的旧值( old value )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要设置值的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 新值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 旧值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getAndSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().getAndSet(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 key 所储存的字符串值，获取指定偏移量上的位( bit )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定偏移量上的 位( 0 / 1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getBit</span><span class="params">(String key, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().getBit(key, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量获取 key 的 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys 要获取值的 键 的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key对应的值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">multiGet</span><span class="params">(Collection&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().multiGet(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置ASCII码, 字符串&#x27;a&#x27;的ASCII码是97, 转为二进制是&#x27;01100001&#x27;, 此方法是将二进制第 offset 位值变为 value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    要设置的 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 偏移多少位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value  值, true 为 1,  false 为 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功返回 true, 设置失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">setBit</span><span class="params">(String key, <span class="type">long</span> offset, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().setBit(key, offset, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将值 value 关联到 key ，并将 key 的过期时间设为 timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位, 天: TimeUnit.DAYS 小时: TimeUnit.HOURS 分钟: TimeUnit.MINUTES</span></span><br><span class="line"><span class="comment">     *                秒: TimeUnit.SECONDS 毫秒: TimeUnit.MILLISECONDS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEx</span><span class="params">(String key, Object value, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有在 key 不存在时设置 key 的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 之前已经存在返回 false, 不存在返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">setIfAbsent</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value  值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 从指定位置开始覆写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRange</span><span class="params">(String key, Object value, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字符串的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该 key 对应的 值的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">size</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加 key-value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maps key-value 的 map 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiSet</span><span class="params">(Map&lt;String, Object&gt; maps)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().multiSet(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在才会设置成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maps key-value 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 之前已经存在返回 false, 不存在返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">multiSetIfAbsent</span><span class="params">(Map&lt;String, Object&gt; maps)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().multiSetIfAbsent(maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加(自增长), 负数则为自减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increment 自增量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">incrBy</span><span class="params">(String key, <span class="type">long</span> increment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自增长, 增长量为浮点数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increment 自增量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">incrByFloat</span><span class="params">(String key, <span class="type">double</span> increment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 value 追加到指定 key 的值的末尾</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要追加的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 追加值后新值的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">append</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().append(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------hash 相关操作-------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取存储在哈希表中指定字段的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field 字段名( 即 map 中的 key )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hGet</span><span class="params">(String key, String field)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取给定 哈希表 中的所有键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所有的 键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hGetAll</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定 哈希表 中所有给定字段的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fields 要获取值的字段集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表中所有给定字段的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">hMultiGet</span><span class="params">(String key, Collection&lt;Object&gt; fields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().multiGet(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向指定 哈希表 中存储一个 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey 字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hPut</span><span class="params">(String key, String hashKey, Object value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向指定 哈希表 中存储多个 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maps 键值对集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hPutAll</span><span class="params">(String key, Map&lt;String, Object&gt; maps)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().putAll(key, maps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅当 hashKey 不存在时才设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashKey 字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功返回 true, 设置失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">hPutIfAbsent</span><span class="params">(String key, String hashKey, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().putIfAbsent(key, hashKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除哈希表中一个或多个字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fields 要删除的字段集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除成功的数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">hDelete</span><span class="params">(String key, Object... fields)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().delete(key, fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看哈希表中指定的字段是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   要查看的哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field 字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在返回 true, 不存在返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hExists</span><span class="params">(String key, String field)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为哈希表 key 中的指定字段的整数值加上增量 increment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       指定的哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field     字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> increment 增加的量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">hIncrBy</span><span class="params">(String key, Object field, <span class="type">long</span> increment)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, field, increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为哈希表 key 中的指定字段的整数值加上增量 increment( 浮点型 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   指定的哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field 字段名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 增加的量( 浮点型 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">hIncrByFloat</span><span class="params">(String key, Object field, <span class="type">double</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, field, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有哈希表中的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所有的 字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">hKeys</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().keys(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希表中字段的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表所有字段的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">hSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取哈希表中所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 哈希表中所有的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">hValues</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().values(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代哈希表中的键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     哈希表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> options 迭代的限制条件, 为 ScanOptions.NONE 则无限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个键值对元组的游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Cursor&lt;Entry&lt;Object, Object&gt;&gt; <span class="title function_">hScan</span><span class="params">(String key, ScanOptions options)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------list 相关操作----------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引获取列表中的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   元素所在的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 下标, 从 0 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表中指定下标的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表指定范围内的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   元素所在列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置, 0 是开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置, -1 返回所有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定索引范围内的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在 list 头部( 左边 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 存储的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPush</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个值存入列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值, 可以输入多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPushAll</span><span class="params">(String key, Object... value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个值存入列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPushAll</span><span class="params">(String key, Collection&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 list 存在的时候才加入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPushIfPresent</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 pivot 存在,在 pivot 前面添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pivot 基准值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要添加的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLeftPush</span><span class="params">(String key, Object pivot, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储在 list 尾部( 右边 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPush</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个值存入列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值, 可以输入多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPushAll</span><span class="params">(String key, Object... value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将多个值存入列表中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPushAll</span><span class="params">(String key, Collection&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为已存在的列表添加值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   存在的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPushIfPresent</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPushIfPresent(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 pivot 元素的右边添加值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pivot 基准值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要添加的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRightPush</span><span class="params">(String key, Object pivot, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPush(key, pivot, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引设置列表元素的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lSet</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移出并获取列表的第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lLeftPop</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移出并获取列表的第一个元素, 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lBLeftPop</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().leftPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并获取列表最后一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lRightPop</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移出并获取列表的最后一个元素, 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lBRightPop</span><span class="params">(String key, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPop(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceKey      要移除元素的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destinationKey 要添加元素的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移动的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lRightPopAndLeftPush</span><span class="params">(String sourceKey, String destinationKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPopAndLeftPush(sourceKey, destinationKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它; 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceKey      要移除元素的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destinationKey 要添加元素的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout        等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit           时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移动的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lBRightPopAndLeftPush</span><span class="params">(String sourceKey, String destinationKey, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().rightPopAndLeftPush(sourceKey, destinationKey, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除集合中值等于 value 的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index = 0, 删除所有值等于value的元素;</span></span><br><span class="line"><span class="comment">     *              index &gt; 0, 从头部开始删除第一个值等于 value 的元素;</span></span><br><span class="line"><span class="comment">     *              index &lt; 0, 从尾部开始删除第一个值等于 value 的元素;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().remove(key, index, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 裁剪 list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> &lt;a href=&quot;https://redis.io/commands/ltrim&quot;&gt;Redis Documentation: LTRIM&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lTrim</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().trim(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">lLen</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------set 相关操作--------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set 添加元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值, 可以同时添加多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sAdd</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set 移除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 要移除的元素, 可以同时移除多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除并返回集合的一个随机元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中随机一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sPop</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().pop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素 value 从一个集合移到另一个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     被移除的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   要移除的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey 移动到的目标集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移动成功返回 true, 移动失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">sMove</span><span class="params">(String key, Object value, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().move(key, value, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断集合是否包含 value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含返回 true, 不包含返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">sIsMember</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个集合的交集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个集合的交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sIntersect</span><span class="params">(String key, String otherKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().intersect(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 集合与多个集合的交集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 多个集合的交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sIntersect</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().intersect(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与 otherKey 集合的交集存储到 destKey 集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sIntersectAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().intersectAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与多个集合的交集存储到 destKey 集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sIntersectAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().intersectAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个集合的并集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个集合的并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sUnion</span><span class="params">(String key, String otherKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 集合与多个集合的并集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 多个集合的并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sUnion</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().union(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与 otherKey 集合的并集存储到 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sUnionAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与多个集合的并集存储到 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sUnionAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取两个集合的差集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合1 - 集合2 的差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sDifference</span><span class="params">(String key, String otherKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().difference(key, otherKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 集合与多个集合的差集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合1 - 集合2 - 集合3 - ... 集合n 的差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sDifference</span><span class="params">(String key, Collection&lt;String&gt; otherKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().difference(key, otherKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与 otherKey 集合的差集存储到 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sDifference</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().differenceAndStore(key, otherKey,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key 集合与多个集合的差集存储到 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">sDifference</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().differenceAndStore(key, otherKeys,</span><br><span class="line">                destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合所有元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中所有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">setMembers</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机获取集合中的一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中随机一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sRandomMember</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().randomMember(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机获取集合中 count 个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 要获取的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> count 个随机元素组成的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">sRandomMembers</span><span class="params">(String key, <span class="type">long</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().randomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机获取集合中 count 个元素并且去除重复的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 要获取的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> count 个随机元素组成的集合, 并且不包含重复元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sDistinctRandomMembers</span><span class="params">(String key, <span class="type">long</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().distinctRandomMembers(key, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代集合中的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> options 迭代的限制条件, 为 ScanOptions.NONE 则无限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素的游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Cursor&lt;Object&gt; <span class="title function_">sScan</span><span class="params">(String key, ScanOptions options)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------zSet 相关操作--------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素, 有序集合是按照元素的 score 值由小到大排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> score 分数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 添加成功返回 true, 添加失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">zAdd</span><span class="params">(String key, Object value, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().add(key, value, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加多个元素到有序集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 多个元素值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 有序集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zAdd</span><span class="params">(String key, Set&lt;TypedTuple&lt;Object&gt;&gt; values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().add(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除有序集合中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 要移除的值, 可以同时移除多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 有序集合长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().remove(key, values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加元素的 score 值，并返回增加后的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要增加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 增加的分数是多少</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 增加后的分数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">zIncrementScore</span><span class="params">(String key, Object value, <span class="type">double</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().incrementScore(key, value, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回元素在集合的排名,有序集合是按照元素的 score 值由小到大排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排名, 从小到大顺序, 0 表示第一位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zRank</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回元素在集合的排名,按元素的 score 值由大到小排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排名, 从大到小顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zReverseRank</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRank(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合的元素, 从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置, -1 表示从开始位置开始后面的所有元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定区间的值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合元素, 并且把 score 值也获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置, -1 表示从开始位置开始后面的所有元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定区间的元素及分数的元组的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zRangeWithScores</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rangeWithScores(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数 在最小值与最大值之间的元素集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zRangeByScore</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素及其分数, 并按分数从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数 在最小值与最大值之间的元素与分数的元组的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zRangeByScoreWithScores</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素及其分数, 从小到大排序, 只获取 start 到 end 位置之间的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min   最低分数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max   最高分数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在 min 与 max 之间, 位置在 start 与 end 之间的元素与分数的元组的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zRangeByScoreWithScores</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().rangeByScoreWithScores(key, min, max, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合的元素, 从大到小排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 按照 分数 倒序的元素集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zReverseRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRange(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合的元素, 从大到小排序, 并返回 score 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定区间的元素及其分数的元组的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zReverseRangeWithScores</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeWithScores(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素, 从大到小排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在 min 与 max 之间的元素的集合, 按分数倒序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zReverseRangeByScore</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素, 从大到小排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在 min 与 max 之间的元素与分数的元组的集合, 按分数倒序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zReverseRangeByScoreWithScores</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值查询集合元素及其分数, 从小到大排序, 只获取 start 到 end 位置之间的结果, 按分数从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min   分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max   分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在 min 与 max 之间, 位置在 start 与 end 之间的元素与分数的元组的集合, 按分数倒序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">zReverseRangeByScore</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().reverseRangeByScore(key, min, max, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 score 值获取集合元素数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分数在最小值与最大值之间的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zCount</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().count(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合大小( 底层实现还是 zcard )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().size(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 集合中的元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zZCard</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().zCard(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取集合中 value 元素的 score 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 元素值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该元素值的分数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">zScore</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().score(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除指定索引位置的成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zRemoveRange</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().removeRange(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的 score 值的范围来移除成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> min 分数最小值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max 分数最大值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zRemoveRangeByScore</span><span class="params">(String key, <span class="type">double</span> min, <span class="type">double</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().removeRangeByScore(key, min, max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 和 otherKey 的并集并存储在 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zUnionAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().unionAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 和 otherKeys 的并集并存储在 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zUnionAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().unionAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 和 otherKey 的交集并存储在 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKey 集合2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey  用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zIntersectAndStore</span><span class="params">(String key, String otherKey, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().intersectAndStore(key, otherKey, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 key 和 otherKeys 的交集并存储在 destKey 中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       集合1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherKeys 其余多个集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destKey   用于保存结果的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新集合的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">zIntersectAndStore</span><span class="params">(String key, Collection&lt;String&gt; otherKeys, String destKey)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().intersectAndStore(key, otherKeys, destKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 有序集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> options 迭代限制条件, 为 ScanOptions.NONE 则无限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个元素及分数元组的游标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Cursor&lt;TypedTuple&lt;Object&gt;&gt; <span class="title function_">zScan</span><span class="params">(String key, ScanOptions options)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().scan(key, options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SpringBoot整合Redis</summary>
    
    
    
    <category term="后台成长历程" scheme="https://blog.hiles.cn/categories/%E5%90%8E%E5%8F%B0%E6%88%90%E9%95%BF%E5%8E%86%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://blog.hiles.cn/tags/java/"/>
    
    <category term="springboot" scheme="https://blog.hiles.cn/tags/springboot/"/>
    
    <category term="redis" scheme="https://blog.hiles.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://blog.hiles.cn/posts/f7ede91d.html"/>
    <id>https://blog.hiles.cn/posts/f7ede91d.html</id>
    <published>2022-09-07T06:39:17.000Z</published>
    <updated>2022-09-07T09:35:31.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java学习！"><a href="#Java学习！" class="headerlink" title="Java学习！"></a>Java学习！</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一行的第三个单词必和文件名一样</span></span><br><span class="line"><span class="comment">// public class 后面代表定义一个类的名称 类是Java当中所有源码的基本组织单位。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">//第二行代表main方法</span></span><br><span class="line">    <span class="comment">//执行程序的起点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//输入输出语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>整数型  byte short int long</p><p>浮点型 float double </p><p>字符型 char </p><p>布尔型 boolean</p><p>P.S float的数据范围比long大</p><p>自动类型转换：可以从小到大转（数据范围）</p><p>强制类型转换：可以大到小，也可以小到大；（一般不推荐使用，可能会发生数据精度缺失）</p><p>byte /shot/char运算时首先提升为int型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">num3</span> <span class="operator">=</span> num1 + num2; <span class="comment">//编译出错！</span></span><br><span class="line">        <span class="comment">//byte + byte --&gt;int + int--&gt;int</span></span><br><span class="line">        <span class="comment">//同理：</span></span><br><span class="line">        <span class="comment">//short + byte --&gt; int + int--&gt;int</span></span><br><span class="line">        <span class="comment">//解决方法：使用强制类型转换;</span></span><br><span class="line">        <span class="comment">//但必须注意保证逻辑上的数据范围！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boolean型不能发生强制类型转换！</p><p>int + double —&gt; double + double —&gt;double</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><h4 id="号"><a href="#号" class="headerlink" title="+号"></a>+号</h4><p>对于字符串来说“+”号代表着字符串连接操作！任何数据类型和字符串进行连接时，结果都会变成字符串；</p><h3 id="自增-自减"><a href="#自增-自减" class="headerlink" title="自增 自减"></a>自增 自减</h3><p>前置：变量先自增（减），后使用；</p><p>后置：变量先使用，后自增（减）；</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个格式:</span></span><br><span class="line"><span class="comment">public static void 方法名 ()&#123;</span></span><br><span class="line"><span class="comment">方法体；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">不能嵌套定义；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Prin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Prin</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">完整格式：</span></span><br><span class="line"><span class="comment">修饰符 返回值类型 方法名(参数类型 参数名，.....)&#123;</span></span><br><span class="line"><span class="comment">方法体；</span></span><br><span class="line"><span class="comment">return 返回值；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       System.out.println(Add(<span class="number">10</span>,<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>多个方法的名称一样，但是参数列表不同；</p><p>与下列因素有关：</p><p>1.参数个数不同；</p><p>2.参数类型不同；</p><p>3.参数的多类型顺序不同；</p><p>与下列因素无关：</p><p>1.参数名称无关；</p><p>2.返回值类型无关；</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>初始化数组：</p><p>动态(指定长度)：   数据类型[] 数组名称 = new 数据类型[数组长度];</p><p>元素自动初始化为0(整型)/0.0(浮点型)/‘\u0000’(字符型)/false(布尔型)/null(引用类型  )；</p><p>静态(指定内容)：   数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2,};</p><p>静态省略格式：     数据类型[] 数组名称 = { 元素1, 元素2,};.</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>“静态创建对象指的是在栈上创建对象,比如A a;它会在对象的作用域结束后自动销毁. 动态创建对象指的是在堆上创建对象,然后栈上的指针指向创建的对象.比如A *pa = new A();它需要程序员手动delete掉.如果不进行delete操作,只能等到程序结束后,由OS来回收掉.</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> <span class="comment">// 成员变量  定义在方法外，类里面</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 成员方法  成员方法不要写static关键字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125; <span class="comment">//吃</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span> &#123;&#125; <span class="comment">//喝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;&#125; <span class="comment">//玩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;&#125; <span class="comment">//睡</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，一个类不能直接使用，需要根据类创建一个对象，才能使用；</p><p>1.导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名称.类名称</span><br><span class="line">对于和当前类属于同一个包的情况，可以省略；</span><br><span class="line">只有java.lang包下的内容不用导包，其他的包都需要<span class="keyword">import</span>语句</span><br></pre></td></tr></table></figure><p>2.创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名称 对象名 = <span class="keyword">new</span> 类名称();</span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure><p>3.使用</p><p>使用成员变量： 对象名.成员变量</p><p>使用成员方法： 对象名.成员方法</p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><p>可以实现键盘输入数据到程序中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sca</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        <span class="comment">//备注：System.in代表从键盘进行输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">     <span class="comment">//使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">//获取数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next(); <span class="comment">//获取字符串 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   String name;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Showname</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().name = <span class="string">&quot;邱&quot;</span>;</span><br><span class="line">        <span class="comment">//Scanner </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名对象传参</span></span><br><span class="line">        Niin(<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回匿名对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> niout();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Niin</span><span class="params">(Scanner sc)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title function_">Niout</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">        return sc;*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用建议：如果确定有一个对象只需要使用唯一一次，就可以使用匿名对象；</p><p>注意事项：匿名对象只能使用唯一的一次，下次使用不得不再创建一个对象；</p><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ra</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="comment">//获取一个随机的int型数字（范围为int的数据范围）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">        <span class="comment">//获取一个随机的int型数字（范围为参数，左闭右开）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt(<span class="number">3</span>); <span class="comment">//[0,3)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> r.nextInt(<span class="number">3</span>); <span class="comment">//[1,4) </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><p>ArrayList类集合不同于数组，数组长度不可变，ArrayList长度可变；</p><p>&lt; E &gt; 泛型 代表着装在集合中的所有元素都是同一类型；注意 只能是引用类型，不能是基本类型；</p><p>对于ArrayList集合来说，直接打印得到的不是地址值，而是内容；若内容为空，则得到空的中括号；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//ArrayList</span></span><br><span class="line">        <span class="comment">//创建了一个ArrayList集合，集合名称为list，里面装的是String类型数据</span></span><br><span class="line">        <span class="comment">//备注：从JDK1.7+开始，右侧尖括号内部可空，但尖括号仍需要存在！</span></span><br><span class="line">        ArrayList&lt;String&gt; list  =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        常用方法</span></span><br><span class="line"><span class="comment">        public boolean add(E  e); 向集合当中添加元素，参数的类型和泛型一致。返回值代表是否成功；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public E get(int index);  从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public E remove(int index); 从集合当中删除元素，参数是索引编号，返回值就是被删除的元素；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public int size();      获取集合的尺寸长度，返回值为集合中包含的元素个数；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 add</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> list.add(<span class="string">&quot;qiu&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.add(<span class="string">&quot;wu&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;lu&quot;</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">//[qiu, wu, lu]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取元素 get</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(name); <span class="comment">//wu</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除元素 remove</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">whoremove</span> <span class="operator">=</span> list.remove(<span class="number">1</span>);</span><br><span class="line">        System.out.println(whoremove);  <span class="comment">//wu</span></span><br><span class="line">        System.out.println(list);       <span class="comment">//[qiu, lu]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合长度 size</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的长度是&quot;</span> + size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对于的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本类型      包装类（引用类型，包装类都位于Java.lang包下）</span></span><br><span class="line"><span class="comment">byteByte</span></span><br><span class="line"><span class="comment">shortShort</span></span><br><span class="line"><span class="comment">intInteger</span></span><br><span class="line"><span class="comment">long Long</span></span><br><span class="line"><span class="comment">floatFloat</span></span><br><span class="line"><span class="comment">doubleDouble</span></span><br><span class="line"><span class="comment">charCharacter</span></span><br><span class="line"><span class="comment">booleanBoolean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demoArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">        list.add(<span class="number">200</span>);</span><br><span class="line">        System.out.println(list); <span class="comment">//[100, 200]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一号元素是&quot;</span> + num); <span class="comment">//第一号元素是200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String类代表字符串；字符串是常量；</p><p>字符串的效果相当于是char[]字符数组，但底层原理是byte[]字节数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">()</span>；<span class="comment">//创建一个空白字符串，不含有任何内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span>[] Array)</span>;<span class="comment">//根据字符数组的内容，来创建对应的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] array = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">byte</span>[] array)</span>; <span class="comment">//根据字节数组的内容，来创建对应的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] array1 = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一种直接创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字符串常量池(在堆中)：程序当中直接写上的双引号字符串，就在字符串常量池中；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line">str4 == str2  <span class="comment">//返回值为false</span></span><br><span class="line">str5 == str4<span class="comment">//返回值为true 地址值一样因为字符串为常量具有可共享的属性</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于基本类型来说；==是进行数值比较</span></span><br><span class="line"><span class="comment">    对于引用类型来说；==是进行地址值的比较</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串内容比较</span></span><br><span class="line"><span class="comment">    public boolean equals(Object obj):参数可以是任何对象，只有参数是一个字符串且内容相同才会返回true</span></span><br><span class="line"><span class="comment">任何对象都可以用object接收</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public boolean equalsIgnoreCase(String str); 忽略大小写进行比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    str4.equals(str2); --&gt;<span class="literal">true</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>.equals(str2); --&gt;<span class="literal">true</span><span class="comment">//推荐 “abc”.equals(str); 若str为null时,上一种方法会报错空指针异常</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*字符串获取方法</span></span><br><span class="line"><span class="comment">public int length(); //获取字符串长度</span></span><br><span class="line"><span class="comment">public String concat(String str);//拼接字符串</span></span><br><span class="line"><span class="comment">public char charAt(int index);//获取指定索引位置的字符</span></span><br><span class="line"><span class="comment">public int indexOf(String str);//查找参数字符串在本字符串出现的首个索引位置，无则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*字符串截取方法</span></span><br><span class="line"><span class="comment">public String substring(int index);//截取从参数位置到最后的字符串</span></span><br><span class="line"><span class="comment">public String substring(int begin,int end);//截取[begin,end)范围的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*字符串转换方法</span></span><br><span class="line"><span class="comment">public char[] toCharArray();//当前字符串拆分成字符数组</span></span><br><span class="line"><span class="comment">public byte[] getBytes();//当前字符串拆分成字节数组</span></span><br><span class="line"><span class="comment">public String replace(CharSequence oldString,CharSequence newString);</span></span><br><span class="line"><span class="comment">将所有出现的老字符串替换成新的字符串，返回替换之后的新字符串；</span></span><br><span class="line"><span class="comment">CharSequence 可以接收字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*字符串截取方法</span></span><br><span class="line"><span class="comment">public String[] split(String regex); //按照参数规则切割字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><h3 id="static静态"><a href="#static静态" class="headerlink" title="static静态"></a>static静态</h3><p>一旦使用static关键字，那么这样的内容不再属于对象自己，而是属于类的，所以凡是本类的对象，都共享同一份； </p><p>一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，属于类；</p><p>如果没有static关键字，那么必须先创建对象，然后通过对象才能使用成员方法；</p><p>对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用；</p><p>P.s 静态不能直接访问非静态；原因：在内存当中先有的静态内容，后有的非静态内容；</p><p>​      静态方法当中不使用this关键字；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String Room;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idCounter</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//每当new一个新对象的时候计数器++</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Staticmethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//首先创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()；</span><br><span class="line">        <span class="comment">//然后才能调用无static关键字的方法</span></span><br><span class="line">        one.method();</span><br><span class="line">        <span class="comment">//静态方法：两者都正确，但推荐使用第二种方法；</span></span><br><span class="line">        one.Staticmethod();</span><br><span class="line">        Student.Staticmethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态代码块：</span></span><br><span class="line"><span class="comment">public class 类名称&#123;</span></span><br><span class="line"><span class="comment">static &#123;</span></span><br><span class="line"><span class="comment">//静态代码块内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">特点：当第一次用到本类时，静态代码块执行唯一的一次；</span></span><br><span class="line"><span class="comment">静态内容总是优先于非静态，所以静态代码块比构造方法先执行；</span></span><br><span class="line"><span class="comment">典型用途：</span></span><br><span class="line"><span class="comment">用来一次性地对静态成员变量进行赋值；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(数组)</span>:将参数数组变成字符串(按照默认格式：[元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3</span>])；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(数组)</span>: 将参数数组升序排序（字符按字典序）；</span><br><span class="line">如果是自定义的类型，那么这个自定义的类需要有Comparable或Comparator接口支持；</span><br></pre></td></tr></table></figure><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>java.util.Math是一个与数学相关的工具类，里面提供了大量静态方法，用来实现数学常见操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">abs</span><span class="params">(<span class="type">double</span> num)</span>:获取绝对值</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> num)</span>:向上取整</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floot</span><span class="params">(<span class="type">double</span> num)</span>:向下取整</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> num)</span>:四舍五入</span><br><span class="line">Math.PI Π的近似值</span><br></pre></td></tr></table></figure><h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><h3 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h3><p>三大特征：封装性，继承性，多态性；</p><p>继承是多态的前提；如果没有继承，就没有多态；</p><p>继承主要解决的问题就是：<strong>共性抽取</strong></p><p>共性存放于父类，也叫基类，超类；</p><p>特殊的存放于子类，也叫派生类；</p><p>继承关系中的特点：</p><p>1.子类可以拥有父类的“内容”；</p><p>2.子类还可以拥有自己的专属内容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在继承的关系中，“子类就是一个父类”；也就是说，子类可以被当成父类看待；</span></span><br><span class="line"><span class="comment">例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义父类格式：</span></span><br><span class="line"><span class="comment">public class 父类名称&#123;</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义子类格式:</span></span><br><span class="line"><span class="comment">public class 子类名称 extends 父类名称&#123;</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</span></span><br><span class="line"><span class="comment">1.直接通过子类对象访问成员变量</span></span><br><span class="line"><span class="comment">(new的时候)等号左边是谁就优先用谁，没有则向上找；</span></span><br><span class="line"><span class="comment">2.间接通过成员方法访问成员变量</span></span><br><span class="line"><span class="comment">方法是哪类的就优先使用哪类的成员变量，无则向上找；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">局部变量：直接写成员变量名</span></span><br><span class="line"><span class="comment">本类的成员变量：  this.成员变量名</span></span><br><span class="line"><span class="comment">父类的成员变量：  super.成员变量名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</span></span><br><span class="line"><span class="comment">创建的对象是谁就优先用谁；无则向上找；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的重写（Override）</span></span><br><span class="line"><span class="comment">概念：在继承关系当中，方法名称一样，参数列表也一样；</span></span><br><span class="line"><span class="comment">方法的覆盖重写特点：创建的是子类对象，则优先使用子类方法；</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">1.必须保证父子类之间的方法名称相同，参数列表也相同；</span></span><br><span class="line"><span class="comment">@Override：写在方法前面用来检测是不是有效的覆盖重写；</span></span><br><span class="line"><span class="comment">这个注解就算不写，只要满足要求，也是正确的方法覆盖重写；</span></span><br><span class="line"><span class="comment">2.子类方法的返回值必须小于等于父类方法的返回值范围；</span></span><br><span class="line"><span class="comment">object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类；</span></span><br><span class="line"><span class="comment">3.子类方法的权限必须大于等于父类方法的权限修饰符；</span></span><br><span class="line"><span class="comment">public &gt; protected &gt; (default) &gt; private</span></span><br><span class="line"><span class="comment">备：(default)不是关键字default，而是什么都不写，留空；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设计原则：</span></span><br><span class="line"><span class="comment">对于已经投入使用的类，尽量不要进行修改；</span></span><br><span class="line"><span class="comment">推荐定义一个新的类，来重复利用其中的共性内容，并添加改动的新内容；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment">1.子类构造方法当中有个隐含的“super()”调用（先构造父类后构造子类）；每当new上一个子类，系统便会new上一个父类；</span></span><br><span class="line"><span class="comment">2.可以通过super关键字来子类构造调用父类重载构造方法；</span></span><br><span class="line"><span class="comment">3.super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造方法中调用多次super构造；</span></span><br><span class="line"><span class="comment">4.子类必须调用父类构造方法，不写系统自动补充super()；写了则用指定的super调用方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字：</span></span><br><span class="line"><span class="comment">1.在子类的成员方法中，访问父类的成员变量；</span></span><br><span class="line"><span class="comment">2.在子类的成员方法中，访问父类的成员方法；</span></span><br><span class="line"><span class="comment">3.在子类的构造方法中，访问父类的构造方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字：</span></span><br><span class="line"><span class="comment">1.在本类的成员方法中，访问本类的成员变量；</span></span><br><span class="line"><span class="comment">2.在本类的成员方法中，访问本类的另一个成员方法；</span></span><br><span class="line"><span class="comment">3.在本类的构造方法中，访问本类的另一个构造方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">java语言是单继承的；</span></span><br><span class="line"><span class="comment">一个类的直接父亲只能有唯一一个；</span></span><br><span class="line"><span class="comment">java可以多级继承；</span></span><br><span class="line"><span class="comment">class A&#123;&#125;;</span></span><br><span class="line"><span class="comment">class B extends A&#123;&#125;;</span></span><br><span class="line"><span class="comment">class c extends B&#123;&#125;;</span></span><br><span class="line"><span class="comment">一个子类只有一个直接父类，但一个父类可以有多个子类；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果父类当中的方法不确定任何进行&#123;&#125;方法体的实现，那么这就应该是一个抽象方法；</span></span><br><span class="line"><span class="comment">抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束；</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类；在class之前加上abstract关键字；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">使用方法：</span></span><br><span class="line"><span class="comment">1.不能直接创建new抽象类对象；</span></span><br><span class="line"><span class="comment">2.必须要一个子类来继承抽象父类；</span></span><br><span class="line"><span class="comment">3.子类必须覆盖重写父类当中所有的抽象方法；</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号；</span></span><br><span class="line"><span class="comment">4.创建子类对象进行使用；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">抽象方法格式：</span></span><br><span class="line"><span class="comment">public abstract 返回值类型 方法名称(参数列表);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：一个抽象类不一定包含抽象方法；没有抽象方法的抽象类也不能直接new对象；子类也可以是抽象类；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是一种公共的标准规范；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口就是多个类的规范；</span></span><br><span class="line"><span class="comment">接口是一种引用类型，最重要的内容就是其中的：抽象方法；</span></span><br><span class="line"><span class="comment">定义格式：</span></span><br><span class="line"><span class="comment">public interface 接口名称&#123;</span></span><br><span class="line"><span class="comment">//接口内容</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Java7 ：</span></span><br><span class="line"><span class="comment">接口中可以有：</span></span><br><span class="line"><span class="comment">1.常量</span></span><br><span class="line"><span class="comment">2.抽象方法</span></span><br><span class="line"><span class="comment">3.默认方法（Java8以上）</span></span><br><span class="line"><span class="comment">4.静态方法（Java8以上）</span></span><br><span class="line"><span class="comment">5.私有方法（Java9以上）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接口当中的抽象方法，修饰符必须是两个固定的关键字： public abstract（可以选择性省略）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接口使用步骤：</span></span><br><span class="line"><span class="comment">1.接口不能直接使用，必须有一个“实现类”来“实现”该接口；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class 实现类名称 implements 接口名称 &#123;</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2.接口的实现类必须覆盖重写（实现）接口中的所有的抽象方法；</span></span><br><span class="line"><span class="comment">去掉abstract关键字，加上方法体大括号；</span></span><br><span class="line"><span class="comment">3.创建实现类的对象，进行使用；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">如果实现类并没有覆盖重写接口中的所有的抽象方法，那么那个实现类自己就必须是抽象类；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Java8开始支持默认方法；备注接口当中的默认方法，可以解决接口升级问题；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public default 返回值类型 方法名称(参数列表)&#123;//public 可省略</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意:</span></span><br><span class="line"><span class="comment">1.接口的默认方法，可以通过接口实现类对象，直接调用；</span></span><br><span class="line"><span class="comment">2.接口的默认方法，可以被接口实现类进行覆盖重写；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Java 8开始允许定义静态方法；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static 返回值类型 方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：不能通过接口实现类的对象来调用接口当中的静态方法；</span></span><br><span class="line"><span class="comment">正确用法：直接通过接口名称直接调用静态方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Java 9接口中允许定义私有方法；</span></span><br><span class="line"><span class="comment">1.普通私有方法，解决多个默认方法之间重复代码问题；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">private 返回值类型 方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2.静态私有方法，解决多个静态方法之间重复代码问题；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">private static 返回值类型 方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接口中可以定义“成员变量” 但是必须使用public static final 这三个关键字进行修饰</span></span><br><span class="line"><span class="comment">从效果上看，这其实是接口的【常量】；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static final 数据类型 常量名称 = 数据值；</span></span><br><span class="line"><span class="comment">一旦使用final关键字进行修饰，说明不可变；</span></span><br><span class="line"><span class="comment">public static final 可以省略，但任然存在；</span></span><br><span class="line"><span class="comment">接口当中的常量，必须进行赋值，不能不赋值；</span></span><br><span class="line"><span class="comment">接口当中的常量的名称，使用完全大写的字母，用下划线进行分隔（推荐命名规则）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.接口不能有静态代码块或者构造方法；</span></span><br><span class="line"><span class="comment">2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public class 实现类名称 implements 接口1,接口2&#123;</span></span><br><span class="line"><span class="comment">//覆盖重写所有的抽象方法</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3.如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次就好；</span></span><br><span class="line"><span class="comment">4.如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类必须是一个抽象类；</span></span><br><span class="line"><span class="comment">5.如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写</span></span><br><span class="line"><span class="comment">6.一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先使用父类当中的方法；</span></span><br><span class="line"><span class="comment">7.类与接口之间是多实现的，一个类可以实现多个接口；</span></span><br><span class="line"><span class="comment">8.接口与接口之间是多继承的；</span></span><br><span class="line"><span class="comment">8.1.多个父接口当中的抽象方法如果重复，没关系；</span></span><br><span class="line"><span class="comment">8.2.多个父接口当中的默认方法不能重复，需要在子接口中进行默认方法覆盖重写（default关键字不可省略）；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个对象拥有多种形态，这也就是对象的多态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码当中体现多态性，父类引用指向子类对象；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">父类名称 对象名 = new 子类名称()；</span></span><br><span class="line"><span class="comment">或者</span></span><br><span class="line"><span class="comment">接口名称 对象名 = new 实现类名称();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员方法:</span></span><br><span class="line"><span class="comment">口诀：编译看左边，运行看右边；</span></span><br><span class="line"><span class="comment">成员变量：</span></span><br><span class="line"><span class="comment">口诀：编译看左边，运行看左边；  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对象的向上转型，其实就是多态的写法；</span></span><br><span class="line"><span class="comment">格式：父类名称 对象名 = new 子类名称；</span></span><br><span class="line"><span class="comment">含义：右侧创建了一个子类对象，把他当成父类来看待使用；</span></span><br><span class="line"><span class="comment">注意事项：向上转型一定是安全的；从小范围转向大范围；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对象一旦向上转型为父类，那么就无法调用子类原本特有的内容；</span></span><br><span class="line"><span class="comment">解决方案：</span></span><br><span class="line"><span class="comment">对象的向下转型：其实是一个还原的动作：</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">子类名称 对象名 = (子类名称)父类对象；</span></span><br><span class="line"><span class="comment">含义：将父类对象，还原成为本来的子类对象；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何才能知道一个父类引用对象，本来是什么子类？</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">对象 instanceof 类名称；</span></span><br><span class="line"><span class="comment">这将会得到一个Boolean值，也就是判断前面的对象是否能够成为后面类型的实例；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第十天"><a href="#第十天" class="headerlink" title="第十天"></a>第十天</h2><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">final关键字代表最终，不可改变的</span></span><br><span class="line"><span class="comment">常见用法：</span></span><br><span class="line"><span class="comment">1.可以修饰一个类</span></span><br><span class="line"><span class="comment">2.可以用来修饰一个方法</span></span><br><span class="line"><span class="comment">3.修饰一个局部变量</span></span><br><span class="line"><span class="comment">4.修饰一个成员变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当final用来修饰一个类的时候</span></span><br><span class="line"><span class="comment">格式:</span></span><br><span class="line"><span class="comment">public final class 类名称&#123;</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">含义：当前这个类不能有任何子类；且其中的所有成员方法都无法进行覆盖重写；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当final用来修饰一个方法的时候，这个方法就是最终方法，不能被覆盖重写；</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">修饰符 final 返回值类型 方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">对于类，方法来说，abstract和final不能同时使用；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一旦用final修饰局部变量，就一次赋值，终身不变；</span></span><br><span class="line"><span class="comment">对于基本类型来说，变量当中的数据不可变；</span></span><br><span class="line"><span class="comment">对于引用类型来说，变量当中的地址值不变；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">final修饰成员变量</span></span><br><span class="line"><span class="comment">1.由于成员变量具有默认值，一旦使用final修饰后必须手动赋值；</span></span><br><span class="line"><span class="comment">2.对于final的成员变量，要么直接赋值，要么通过构造方法赋值；</span></span><br><span class="line"><span class="comment">3.必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java 中有四种权限修饰符：</span></span><br><span class="line"><span class="comment">public &gt; protected &gt; (default) &gt; private</span></span><br><span class="line"><span class="comment">同一个类yes yesyesyes</span></span><br><span class="line"><span class="comment">同一个包yes      yesyesno</span></span><br><span class="line"><span class="comment">不同包子类          yesyes    no    no</span></span><br><span class="line"><span class="comment">不同包非子类   yesno     nono</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：(default)并不是关键字default而是根本不写；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第十一天"><a href="#第十一天" class="headerlink" title="第十一天"></a>第十一天</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>java.lang.Object类是Java语言中的根类，即所有类的父类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String toString(); 返回该对象的字符串表示；(可以获取对象的地址值)</span></span><br><span class="line"><span class="comment">但打印对象的地址值是没有意义的，需要覆盖重写toString方法；</span></span><br><span class="line"><span class="comment">直接打印对象名，其实就是调用对象的toString方法；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">boolean equals(Object obj)； 指示其他某个对象是否与此对象&quot;相等&quot;；</span></span><br><span class="line"><span class="comment">Object类equals方法的源码:</span></span><br><span class="line"><span class="comment">public boolean equals(Object obj)&#123;</span></span><br><span class="line"><span class="comment">return (this == obj);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">方法体：</span></span><br><span class="line"><span class="comment"> == 比较运算符:</span></span><br><span class="line"><span class="comment"> 基本数据类型 比较值；</span></span><br><span class="line"><span class="comment"> 引用数据类型 比较两个对象的地址值;</span></span><br><span class="line"><span class="comment">所以我们应该覆盖重写equals方法，比较两个对象的属性值；</span></span><br><span class="line"><span class="comment">问题:</span></span><br><span class="line"><span class="comment">隐含着一个多态；</span></span><br><span class="line"><span class="comment">多态弊端：无法使用子类的特有内容；</span></span><br><span class="line"><span class="comment">解决：使用向下转型；把Object类型强制转换为当前类型；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jdk7:</span></span><br><span class="line"><span class="comment">public static boolean equals(Object a, Object b)&#123;</span></span><br><span class="line"><span class="comment">retrun (a == b)||(a != null &amp;&amp; a.equals(b));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">对象为空时，不能调用Object的equals方法，这容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题；</span></span><br><span class="line"><span class="comment">*/</span>  </span><br></pre></td></tr></table></figure><h2 id="第十一天-1"><a href="#第十一天-1" class="headerlink" title="第十一天"></a>第十一天</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个事物的内部包含着另一个事物，那么就是一个类的内部包含另一个类；</span></span><br><span class="line"><span class="comment">分类：</span></span><br><span class="line"><span class="comment">1.成员内部类</span></span><br><span class="line"><span class="comment">2.局部内部类(包括匿名内部类)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员内部类：</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">修饰符 class 外部类名称&#123;</span></span><br><span class="line"><span class="comment">修饰符 class 内部类名称&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：内用外，随意访问；外用内，一定需要借助内部类对象；</span></span><br><span class="line"><span class="comment">———————-----------------—————————————————————</span></span><br><span class="line"><span class="comment">使用成员内部类方法：</span></span><br><span class="line"><span class="comment">1.间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类方法；</span></span><br><span class="line"><span class="comment">2.直接方式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</span></span><br><span class="line"><span class="comment">如果出现了重名现象： 外部类.this.外部类成员变量名；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">局部内部类：定义于一个方法的内部；</span></span><br><span class="line"><span class="comment">“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不可使用了；</span></span><br><span class="line"><span class="comment">定义格式:</span></span><br><span class="line"><span class="comment">修饰符 class 外部类名称&#123;</span></span><br><span class="line"><span class="comment">修饰符 返回值类型 外部类方法名称(参数列表)&#123;</span></span><br><span class="line"><span class="comment">class 局部内部类名称&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的；</span></span><br><span class="line"><span class="comment">原因：</span></span><br><span class="line"><span class="comment">1.new出来的对象在堆内存中；</span></span><br><span class="line"><span class="comment">2.局部变量跟着方法在栈内存中；</span></span><br><span class="line"><span class="comment">3.方法运行完之后会立即出栈，局部变量消失；</span></span><br><span class="line"><span class="comment">4.但是new出来的对象会在堆中持续存在，直到垃圾回收消失； </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名内部类：</span></span><br><span class="line"><span class="comment">如果接口的实现类（或者是父类的子类）只需要使用唯一的一次</span></span><br><span class="line"><span class="comment">那么这种情况下就可以省略该类的定义，而改为使用【匿名内部类】</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">接口名称 对象名 = new 接口名称()&#123;</span></span><br><span class="line"><span class="comment">//覆盖重写所有的抽象方法；</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">P.s:匿名内部类是省略了【实现类/子类名称】，但匿名对象省略了【对象名】；</span></span><br><span class="line"><span class="comment">匿名内部类和匿名对象不是同一回事；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">权限修饰符：</span></span><br><span class="line"><span class="comment">定义一个类的时候：</span></span><br><span class="line"><span class="comment">1.外部类：public / (default)</span></span><br><span class="line"><span class="comment">2.成员内部类： public / protected / (default) / private</span></span><br><span class="line"><span class="comment">3.局部内部类：什么都不能写； 不同于(default)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="第十二天-日期时间类"><a href="#第十二天-日期时间类" class="headerlink" title="第十二天 日期时间类"></a>第十二天 日期时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Date:表示日期和时间的类；</span></span><br><span class="line"><span class="comment">类Date表示特定的瞬间，精确到毫秒;</span></span><br><span class="line"><span class="comment">时间原点（0毫秒）:1970.1.1 00:00:00(英国格林威治)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">无参：</span></span><br><span class="line"><span class="comment">Date();获取当前的系统的日期和时间；</span></span><br><span class="line"><span class="comment">带参:</span></span><br><span class="line"><span class="comment">Date(long date);传递毫秒值，把毫秒转换为Date日期;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员方法:</span></span><br><span class="line"><span class="comment">long getTime()返回自时间原点以来此Date对象表示的毫秒值；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="DateFormat类-抽象类"><a href="#DateFormat类-抽象类" class="headerlink" title="DateFormat类(抽象类)"></a>DateFormat类(抽象类)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">日期/时间格式化子类的抽象类；</span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">    1.格式化（日期-&gt;文本）</span></span><br><span class="line"><span class="comment">    2.解析（文本-&gt;日期）</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment"> 成员方法：</span></span><br><span class="line"><span class="comment"> String format(Date date)按照指定的模式，把Date日期格式化为符合模式的字符串；</span></span><br><span class="line"><span class="comment"> Date parse(String source)把符合模式的字符串，解析为Date日期；</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">SimpleDateFormat类继承DateFormat类</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">SimpleDateFormat(String pattern)用给定的模式和默认语言环境日期格式构造SimpleDateFormat。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">String patten ：传递指定的模式；</span></span><br><span class="line"><span class="comment">模式：区分大小写</span></span><br><span class="line"><span class="comment">y - 年写对应的模式，会把模式替换成对应的日期和时间；</span></span><br><span class="line"><span class="comment">M - 月</span></span><br><span class="line"><span class="comment">d - 日</span></span><br><span class="line"><span class="comment">H - 时</span></span><br><span class="line"><span class="comment">m - 分</span></span><br><span class="line"><span class="comment">s - 秒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习题</span></span><br><span class="line"><span class="comment">//计算出一个人已经出生了多少天？</span></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入出生日期: 格式 YYYY-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birthDay</span> <span class="operator">=</span> sdf.parse(birth);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">today</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间对应毫秒值：&quot;</span> + today.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;出生日期对应毫秒值：&quot;</span> + birthDay.getTime());</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> today.getTime()-birthDay.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;时间差为：&quot;</span> + time);</span><br><span class="line">        <span class="type">long</span> <span class="variable">day</span> <span class="operator">=</span> time/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;相差天数为：&quot;</span> + day);</span><br><span class="line">        <span class="type">long</span> <span class="variable">year</span> <span class="operator">=</span> day/<span class="number">365</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经&quot;</span> + year + <span class="string">&quot;岁啦！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十三天"><a href="#第十三天" class="headerlink" title="第十三天"></a>第十三天</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常量：</span></span><br><span class="line"><span class="comment">public static final int SPRING = 1;</span></span><br><span class="line"><span class="comment">缺点：类型不安全，可以当做整数参与计算，并且输出的意义不明确！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">枚举类</span></span><br><span class="line"><span class="comment">一种特殊的类，可以清晰的枚举出每一项数据，可以避免错误的运算！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">规范：</span></span><br><span class="line"><span class="comment">1. 枚举类是特殊的类，通过enum关键字进行定义；</span></span><br><span class="line"><span class="comment">2. 枚举类可以定义成员变量、成员方法、构造方法，也可以实现接口；</span></span><br><span class="line"><span class="comment">3. 枚举类默认继承于java.lang.Enum类，并且不能继承于其他父类；</span></span><br><span class="line"><span class="comment">4. 非抽象的枚举类默认使用final修饰，所以枚举类不能派生出子类；</span></span><br><span class="line"><span class="comment">5. 枚举类的构造方法默认使用private修饰，并且只能使用private修饰；</span></span><br><span class="line"><span class="comment">6. 枚举类的所有实例，必须在类中第一行显示列出，它们默认是public static final的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现接口：</span></span><br><span class="line"><span class="comment">可以直接在枚举实例上进行方法重写；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在枚举类中定义抽象方法，需在实例内重写抽象方法；</span></span><br><span class="line"><span class="comment">一般来说enum类为final修饰，一旦定义了抽象方法后被abstra修饰；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="topview面试问题总结"><a href="#topview面试问题总结" class="headerlink" title="topview面试问题总结"></a>topview面试问题总结</h3><h4 id="1-面向接口编程"><a href="#1-面向接口编程" class="headerlink" title="1.面向接口编程"></a>1.面向接口编程</h4><p>疑问：为什么有的地方必须使用接口而不是抽象类，而在另一些地方，又必须使用抽象类而不是接口呢？</p><p>原则：行为模型应该总是通过接口而不是抽象类定义；</p><p>根本的原因在于使用抽象类不仅意味着定义特定的行为，而且意味着定义实现的模式。也就是说，应该定义一个事物如何获得行为的模型，而不仅仅是声明事物具有某一个行为。</p><p>interface关键字用来声明一个接口，它可以产生一个完全抽象的类，并且不提供任何具体实现。interface的特性整理如下：</p><ol><li><p>接口中的方法可以有参数列表和返回类型，但不能有任何方法体。</p></li><li><p>接口中可以包含字段，但是会被隐式的声明为static和final。</p></li><li><p>接口中的字段只是被存储在该接口的静态存储区域内，而不属于该接口。</p></li><li><p>接口中的方法可以被声明为public或不声明，但结果都会按照public类型处理。</p></li><li><p>当实现一个接口时，需要将被定义的方法声明为public类型的，否则为默认访问类型，Java编译器不允许这种情况。</p></li><li><p>如果没有实现接口中所有方法，那么创建的仍然是一个接口。</p></li><li>扩展一个接口来生成新的接口应使用关键字extends，实现一个接口使用implements。</li></ol><p>interface在某些地方和abstract有相似的地方，但是采用哪种方式来声明类主要参照以下两点：</p><ol><li><p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。</p></li><li><p>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</p></li></ol><p>接口应有两类：</p><p>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；</p><p>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</p><h4 id="Linkedlist的底层实现逻辑"><a href="#Linkedlist的底层实现逻辑" class="headerlink" title="Linkedlist的底层实现逻辑"></a>Linkedlist的底层实现逻辑</h4><p><strong>ArrayList和LinkedList的区别如下：</strong></p><ol><li>ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。</li><li>对于随机访问，ArrayList优于LinkedList，ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问。而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)</li><li>对于插入和删除操作，LinkedList优于ArrayList，因为当元素被添加到LinkedList任意位置的时候，不需要像ArrayList那样重新计算大小或者是更新索引。</li><li>LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li></ol><h2 id="第十五天"><a href="#第十五天" class="headerlink" title="第十五天"></a>第十五天</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p>类型确定，长度固定，不适合进行增删操作</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>大小不固定，类型也不固定，适合进行元素的增删操作</p><p>不支持基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可变参数:</span></span><br><span class="line"><span class="comment">在形参中可以接受多个数据 格式： 数据类型...参数名称</span></span><br><span class="line"><span class="comment">可变参数在方法内部其实是一个数组</span></span><br><span class="line"><span class="comment"> 每个方法只能定义一个可变参数</span></span><br><span class="line"><span class="comment"> 一般将可变参数放在参数列表的最后面；</span></span><br><span class="line"><span class="comment">一.单列集合 Collection(集合)(存储元素对象的地址值)</span></span><br><span class="line"><span class="comment">提供的Api：</span></span><br><span class="line"><span class="comment">list.add();添加成功返回true</span></span><br><span class="line"><span class="comment">    list.clear();</span></span><br><span class="line"><span class="comment">    list.isEmpty(); 为空返回true</span></span><br><span class="line"><span class="comment">    list.size();返回集合大小</span></span><br><span class="line"><span class="comment">    list.contains();含有该元素返回true</span></span><br><span class="line"><span class="comment">    list.remove();成功返回true，只会删前面第一个</span></span><br><span class="line"><span class="comment">    list.toArray();默认转成Object[]</span></span><br><span class="line"><span class="comment">    list.addAll();将括号内的集合添加到list</span></span><br><span class="line"><span class="comment">遍历方式：</span></span><br><span class="line"><span class="comment">迭代器：list.iterator()获取迭代器(默认索引位置为0)</span></span><br><span class="line"><span class="comment">方法：boolean hasNext()判断当前位置是否有元素</span></span><br><span class="line"><span class="comment"> E next() 返回当前位置元素，同时将迭代器对象移向下一个位置</span></span><br><span class="line"><span class="comment">foreach：可以遍历集合与数组(必须实现Iterable接口)，无法修改值</span></span><br><span class="line"><span class="comment">Lambert：list.forEach(new Consumer&lt;string&gt;)&#123;重写accept方法&#125;</span></span><br><span class="line"><span class="comment">P.s:</span></span><br><span class="line"><span class="comment">并发修改问题：</span></span><br><span class="line"><span class="comment">当你使用迭代器且使用集合自身remove方法删除元素的时候，会导致删完索引位置的元素后，后面的元素会前移，导致忽略一个元素，此时会抛出异常ConcurrentModificationError;推荐使用迭代器的方法remove；</span></span><br><span class="line"><span class="comment">foreach不能实现并发修改；有上述bug，但无法解决；</span></span><br><span class="line"><span class="comment">for:从末尾开始删除即可；从头开始的话，每当删除一个元素，索引后移（i--）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.list(有序，可重复，有索引)</span></span><br><span class="line"><span class="comment">void add(int index,E e) 指定位置插入元素</span></span><br><span class="line"><span class="comment">E remove(int index)删除索引元素并返回</span></span><br><span class="line"><span class="comment">E set(int index,E e)修改索引元素，并返回修改前的元素</span></span><br><span class="line"><span class="comment">E get(int index)返回索引元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​1.ArrayList</span></span><br><span class="line"><span class="comment">底层原理：</span></span><br><span class="line"><span class="comment">1.第一次创建并添加第一个元素的时候，创建一个长度为10的泛型数组</span></span><br><span class="line"><span class="comment">2.每加一个元素，size++</span></span><br><span class="line"><span class="comment">3.当size要超过当前容量，进行扩容，每次扩容1.5倍；（新建数组）</span></span><br><span class="line"><span class="comment">​2.Linkedlist（点餐可以用linkedlist实现队列）</span></span><br><span class="line"><span class="comment">可以实现栈与队列</span></span><br><span class="line"><span class="comment">特有功能API：</span></span><br><span class="line"><span class="comment">void addFirst(E e)在列表开头插入元素   -&gt;push()</span></span><br><span class="line"><span class="comment">void addLast(E e)在列表末尾追加元素-&gt;offerLast</span></span><br><span class="line"><span class="comment">E getFirst(E e)返回列表第一个元素</span></span><br><span class="line"><span class="comment">E getLast(E e)返回列表第最后一个元素</span></span><br><span class="line"><span class="comment">E removeFirst(E e)删除并返回列表第一个元素-&gt;pop()</span></span><br><span class="line"><span class="comment">E removeLast(E e)删除并返回列表最后一个元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​2.set(无序（非随机无序），不重复，无索引)</span></span><br><span class="line"><span class="comment">如果希望Set集合认为两个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法；</span></span><br><span class="line"><span class="comment">先判断哈希值，后判断equals；                     </span></span><br><span class="line"><span class="comment">​1.HashSets</span></span><br><span class="line"><span class="comment">底层原理：采用哈希表（一种对于增删改查数据性能较好的结构）jdk8之前底层为数组加链表，之后为数组加链表加红黑树；哈希值：根据对象的地址，按照某种规则算出来的int类型数值（可以通过Hashcode()方法获取）</span></span><br><span class="line"><span class="comment">哈希算法：根据元素哈希值跟数组的长度求余计算出应存入的位置；</span></span><br><span class="line"><span class="comment">红黑树的作用：当数组某个位置下的链表节点过多（超过8个），会影响性能，故采用红黑树进行优化；</span></span><br><span class="line"><span class="comment">​1.LinkedHashSet(有序，不重复，无索引)</span></span><br><span class="line"><span class="comment">底层数据结构仍为哈希表，只是每个元素又额外多了一个双链表的机制记录存储的顺序；</span></span><br><span class="line"><span class="comment">​2.TreeSet(按照默认大小升序，不重复，无索引)</span></span><br><span class="line"><span class="comment">底层：基于红黑树实现排序，增删改查性能都较好；一定是有序的，可以指定排序规则；</span></span><br><span class="line"><span class="comment">自定义的类实现comparable接口，重写compareTo方法；或者用Treeset构造器的时候，实现comparable接口的比较器（优先使用）； </span></span><br><span class="line"><span class="comment">返回值规则：第一个元素大于第二个元素返回正整数，小于返回负整数，等于则返回零；相等时会去重；</span></span><br><span class="line"><span class="comment">比较浮点类型时，可以调用Double.compare()方法比较，以避免出现-0.5，0.5强转精度损失，进而被认为相等的情况；</span></span><br><span class="line"><span class="comment">二.双列集合 Map(由键决定)</span></span><br><span class="line"><span class="comment">特点</span></span><br><span class="line"><span class="comment">    无序，不重复，无索引，值不做要求</span></span><br><span class="line"><span class="comment">    后面重复的键对应的值会覆盖前面重复键的值</span></span><br><span class="line"><span class="comment">    键值对可以为null</span></span><br><span class="line"><span class="comment">元素格式：key==value（键值对元素）</span></span><br><span class="line"><span class="comment">如在购物车中，可以把商品对象看成键，购买数量看成值；</span></span><br><span class="line"><span class="comment">Api：</span></span><br><span class="line"><span class="comment">V put(k,v);添加元素</span></span><br><span class="line"><span class="comment">V remove(E k);根据键删除元素</span></span><br><span class="line"><span class="comment">void clear();移除所有键值对</span></span><br><span class="line"><span class="comment">boolean containKey(E k);判断是否含有指定的键</span></span><br><span class="line"><span class="comment">boolean containValue(E v);判断是否含有指定的值</span></span><br><span class="line"><span class="comment">boolean inEmpty();判断集合是否为空</span></span><br><span class="line"><span class="comment">int size();键值对的个数</span></span><br><span class="line"><span class="comment">Set&lt;K&gt; keySet();获取全部键的集合(键不可重复所以用Set接收)</span></span><br><span class="line"><span class="comment">Collection&lt;V&gt; values();获取全部值的集合(值可重复所以用Collection接收)</span></span><br><span class="line"><span class="comment">map1.putAll(map2);将map2的元素添加到map1；</span></span><br><span class="line"><span class="comment">遍历方式：</span></span><br><span class="line"><span class="comment">1.键找值</span></span><br><span class="line"><span class="comment">先拿到集合的全部键（keySet()），然后使用get()方法</span></span><br><span class="line"><span class="comment">2.键值对</span></span><br><span class="line"><span class="comment">Set&lt;Map,Entry&lt;String,Integer&gt;&gt; entries = map.entrySet(); Enrty是一个接口;</span></span><br><span class="line"><span class="comment">先调用entrySet()方法获取所有键值对对象的集合，将每一个键值对封装成一个实例对象，再通过getKey(),getValue()获取键值对；</span></span><br><span class="line"><span class="comment">3.lambda表达式</span></span><br><span class="line"><span class="comment">default void forEach(BiConsumer&lt;k,v&gt; action);</span></span><br><span class="line"><span class="comment">map.forEach(k,v)-&gt;&#123;System.out.println(k + &quot;-&gt;&quot; + v)&#125;</span></span><br><span class="line"><span class="comment">实现类：</span></span><br><span class="line"><span class="comment">1.HashMap(无序，不重复，无索引，值不做要求)</span></span><br><span class="line"><span class="comment"> 底层实现与Hashset相同；HashSet构造方法是调用的HashMap</span></span><br><span class="line"><span class="comment"> 依赖hashCode和equals方法来保证键的唯一；</span></span><br><span class="line"><span class="comment">1.LinkedHashMap(有序，不重复，无索引，值不做要求)</span></span><br><span class="line"><span class="comment">2.HashTable</span></span><br><span class="line"><span class="comment">1.Properties</span></span><br><span class="line"><span class="comment">3.TreeMap(排序（只能对键排序），不重复（只要大小规则一样则判定为重复），无索引，值不做要求)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>精心选择的数据结构可以带来更高的运行或者存储效率</p><p>抽象数据类型（ADT）：一个数学模型以及定义在这模型上的一系列操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈</span></span><br><span class="line"><span class="comment">~后进先出，先进后出(进入称压栈/进栈，离开称出栈/弹栈)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">队列</span></span><br><span class="line"><span class="comment">~后进后出，先进先出(进入称入队，离开称出队)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数组（查询快，增删慢）</span></span><br><span class="line"><span class="comment">~查询速度快：查询数据通过地址值和索引定位，查询任意数据耗时相同（元素在内存中是连续存储的）</span></span><br><span class="line"><span class="comment">~删除效率低：要将原始数据删除，同时后面每个数据前移</span></span><br><span class="line"><span class="comment">~添加效率极低：添加位置后的每个数据后移，再添加元素</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">链表</span></span><br><span class="line"><span class="comment">~查询速度慢：无论查询哪个数据都要通过头节点开始找（元素在内存中不是连续存储的）</span></span><br><span class="line"><span class="comment">~增删效率相对快：只有再增删的时候要快，因为首先要找到增删的位置</span></span><br><span class="line"><span class="comment">~双链表：增删首尾位置的元素极快</span></span><br><span class="line"><span class="comment">（单链表还需要遍历到尾节点进行增加数据，双链表之间在头指针之前插入数据即可）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二叉树</span></span><br><span class="line"><span class="comment">~一个节点包括父节点地址，左右节点地址，及数据域；</span></span><br><span class="line"><span class="comment">~只能有一个根节点，每个节点最多两个直接子节点</span></span><br><span class="line"><span class="comment">~节点的度：节点拥有的子树的个数，二叉树的度不大于2，叶节点度为零的节点，也称之为终端节点；</span></span><br><span class="line"><span class="comment">~叶节点的高度为1，叶子节点的父节点高度为2，根节点的高度最高</span></span><br><span class="line"><span class="comment">~层：根节点为第一层</span></span><br><span class="line"><span class="comment">~兄弟节点：拥有共同父节点的节点互称兄弟节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二叉查找树</span></span><br><span class="line"><span class="comment">~左子树的所有节点值都小于根节点值，右子树反之</span></span><br><span class="line"><span class="comment">目的：提高检索数据的效率</span></span><br><span class="line"><span class="comment">~存入规则：</span></span><br><span class="line"><span class="comment">小的存左边</span></span><br><span class="line"><span class="comment">大的存右边</span></span><br><span class="line"><span class="comment">一样的不存</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">平衡二叉树</span></span><br><span class="line"><span class="comment">~二叉查找树可能会存在“瘸子问题” -&gt;变成单链表</span></span><br><span class="line"><span class="comment">~在满足查找二叉树的大小规则下，让树尽可能层数小</span></span><br><span class="line"><span class="comment">~要求：任意节点左右子树高度差不超过1，任意节点左右子树为平衡二叉树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">红黑树（平衡二叉B树）</span></span><br><span class="line"><span class="comment">~通过红黑规则自平衡</span></span><br><span class="line"><span class="comment">根节点必须是黑色</span></span><br><span class="line"><span class="comment">如果一个节点没有子节点，则该节点相应的指针属性为Nil，这些Nil视为叶节点，叶节点为黑色；</span></span><br><span class="line"><span class="comment">如果某一个节点为红色，那么它的子节点必须是黑色</span></span><br><span class="line"><span class="comment">对于每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</span></span><br><span class="line"><span class="comment">~添加节点红黑都可，但默认推荐红色（效率高）；添加相同个数的元素，默认红，调整次数少；</span></span><br><span class="line"><span class="comment">~增删改查的性能好</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="集合工具类"><a href="#集合工具类" class="headerlink" title="集合工具类"></a>集合工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections类</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">()</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">()</span>打乱list集合的顺序（采用随机数）</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list,Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure><h2 id="第十六天"><a href="#第十六天" class="headerlink" title="第十六天"></a>第十六天</h2><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>集合的数据项在创建的时候提供，并且在整个生命周期都不可改变；</p><p>当集合对象被不可信的库调用时，不可变形式是安全的；</p><p>在List,Set,Map接口当中，都存在of方法，可以创建一个不可变的集合；</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>作用：简化匿名内部类的代码写法（只能简化函数式接口的匿名内部类的写法形式）</p><p>函数式接口：首先必须是接口，其次接口中有且仅有一个抽象方法的形式；通常会在接口上加上@FunctionalInterface注解，标记该接口必须式满足函数式接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">省略写法：</span><br><span class="line">    参数类型可以不写</span><br><span class="line">    如果只有一个参数，参数类型可以省略，同时（）也可以省略</span><br><span class="line">    如果表达式的方法体代码只有一行，可以省略大括号不写，同时要省略分号；若此时这行代码是<span class="keyword">return</span>语句，必须省略<span class="keyword">return</span>不写，同时也必须省略;分号不写</span><br></pre></td></tr></table></figure><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p>得益于Lambda所带来的函数式编程，引入的全新概念 =》流水线</p><p>目的：用于简化集合和数组操作的API</p><p>使用步骤：</p><p>1.先得到集合或数组的Stream流；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合获取当前对象的Stream流</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//数组获取当前对象的Stream流</span></span><br><span class="line"><span class="comment">//(Arrays工具类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span></span><br><span class="line"><span class="comment">//stream类静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span></span><br></pre></td></tr></table></figure><p>2.把元素放上去；</p><p>3.用stream流的简化API操作元素；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于对流中的数据进行过滤。</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br><span class="line"><span class="comment">//获取前几个元素</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> size)</span></span><br><span class="line"><span class="comment">//跳过前几个元素</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line"><span class="comment">//去除流中重复的元素(依赖Hashcode,equals方法)</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span></span><br><span class="line"><span class="comment">//合并a,b两个流为一个流</span></span><br><span class="line"><span class="keyword">static</span> Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream a,Stream b)</span> </span><br><span class="line"><span class="comment">//获取元素个数</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line"><span class="comment">//Map加工方法</span></span><br><span class="line"><span class="comment">//可以给流中的每一个元素进行加工，如在集合元素前加一个字符串 T-&gt;原材料 R-&gt;加工后的</span></span><br><span class="line">stream&lt;T&gt; <span class="title function_">map</span><span class="params">(Function&lt;T,R&gt; function)</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">apply</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;标记&quot;</span> + t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取最大值</span></span><br><span class="line">Opentional&lt;T&gt; <span class="title function_">max</span><span class="params">(comparetor c)</span>;</span><br><span class="line"><span class="comment">/*Demo</span></span><br><span class="line"><span class="comment">需求： 某个公司的开发部门, 分为开发一部和二部， 现在需要进行年中数据结算。</span></span><br><span class="line"><span class="comment">分析</span></span><br><span class="line"><span class="comment">1.员工信息至少包含了（ 名称、性别、工资、奖金、处罚记录）</span></span><br><span class="line"><span class="comment">2.开发一部有4个员工、开发二部有5名员工</span></span><br><span class="line"><span class="comment">3.分别筛选出2个部门的最高工资的员工信息, 封装装成优秀员工对象Topperformer</span></span><br><span class="line"><span class="comment">4.分别统计出2个部门的平均月收入要求去掉最高和最低工资。</span></span><br><span class="line"><span class="comment">5.统计2个开发部门整体的平均工资,去掉最低和最高工资的平均值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*收集Stream流</span></span><br><span class="line"><span class="comment">将流操作后的结果数据传回集合或数组中去；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">R <span class="title function_">collect</span><span class="params">(Collector collector)</span> <span class="comment">//开始收集Stream流。指定收集器</span></span><br><span class="line"><span class="comment">//Collectors工具类提供了具体的收集方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector <span class="title function_">toList</span><span class="params">()</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector <span class="title function_">toSet</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector <span class="title function_">toMap</span><span class="params">(Function keyMapper,Function valueMapper)</span> </span><br><span class="line"><span class="comment">//直接收集成集合 list()方法但返回的是不可变集合</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>程序在“编译”或者“执行”的过程中可能出现的问题，注意：语法错误不算在异常体系中；</p><p>异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止；</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center"></th><th style="text-align:center">Throwable</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td></td><td style="text-align:center">Error</td><td style="text-align:center"></td><td style="text-align:center">Exception</td><td style="text-align:center"></td></tr><tr><td></td><td style="text-align:center"></td><td style="text-align:center">RuntimeException</td><td style="text-align:center"></td><td style="text-align:center">除RuntimeException之外的所有异常</td></tr><tr><td></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><p>Error:系统级别问题，JVM退出等，代码无法控制</p><p>Exception：称为异常类，它表示程序本身可以处理的问题</p><p>RuntimeException及其子类：运行时异常，编译阶段不会报错;</p><p>  除RuntimeException之外的所有异常 :编译时异常，编译期必须处理的，否则程序不能通过编译；</p><p><strong>默认处理流程</strong>：</p><p>​    1.默认会在出现异常的代码那里自动的创建一个异常对象： ArithmeticException 。<br>​    2.异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM 虚拟机。<br>​    3.虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。<br>​    4.直接从当前执行的异常点干掉当前程序。<br>​    5.后续代码没有机会执行了， 因为程序已经死亡。</p><p><strong>异常处理机制</strong>：</p><p><strong>处理方式1：throws 异常1，异常2…</strong></p><p>用在方法上，可以将方法内部出现的异 常抛出去给本方法的调用者处理；规范做法：直接抛出Exception；</p><p><strong>处理方式2：try…catch…</strong></p><p>监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行；建议直接catch(Exception)异常，然后打印异常栈信息；</p><p><strong>处理方式3 前两者结合</strong>（推荐）</p><p>方法直接将异常通过throws抛出给调用者，调用者收到异常后直接捕获处理；  </p><p> <strong>自定义异常</strong></p><p>1.自定义编译时异常<br>· 定义一个异帛类继承Exception.<br>· 重写构造器。<br>· 在出现异常的地方用throw new 自定义对象抛出。</p><p>作用：编译时异常是编译阶段就报错，提醒更加强烈！</p><p>throw ：在方法内部直接创建一个异常对象，并从此点抛出</p><p>throws：用在方法声明上的，抛出方法内部的异常；</p><p>2.自定义运行时异常<br>· 定义一个异帛类继承RuntimeException.<br>· 重写构造器。<br>· 在出现异常的地方用throw new 自定义对象抛出。</p><p>作用：编译阶段不报错，提醒不强烈，运行时才可能出现！</p><h2 id="第十七天"><a href="#第十七天" class="headerlink" title="第十七天"></a>第十七天</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>程序中的日志可以用来记录程序运行过程中的信息，并可以进行永久存储。</p><p>输出语句的弊端：</p><p>· 信息只能展示在控制台；</p><p>· 不能将其记录到其他的位置（文件，数据库）；</p><p>· 想要取消记录的信息需要修改代码才可以完成；</p><p>· 多线程性能较差；</p><p>日志技术的优势：</p><p>· 可以将系统执行的信息选择性的记录到指定的位置（ 控制台、文件中、数据库中） 。<br>· 可以随时以开关的形式控制是否记录日志， 无需修改源代码。</p><p>· 多线程性能较好；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*日志规范接口 - 提供给日志的实现框架设计的标准</span></span><br><span class="line"><span class="comment">Commons Logging</span></span><br><span class="line"><span class="comment">Simple Logging Facade for Java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*日志实现框架</span></span><br><span class="line"><span class="comment">Log4J</span></span><br><span class="line"><span class="comment">Logback -&gt; 实现了slf4j接口 性能优于Log4J</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Logback</strong></p><p>概述：</p><p>logback 分为三个模块，logback-core、logback-classic 和 logback-access。</p><p>· logback-core 模块为其他两个模块奠定了基础。</p><p>· logback-classic 模块可以同化为 log4j 1.x 的显着改进版本。此外，logback-classic 原生实现了SLF4J API，因此您可以轻松地在 logback 和其他日志框架（例如 log4j 1.x 或 java.util.logging (JUL)）之间来回切换。</p><p>· logback-access 模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能。</p><p><strong>！！需第三方jar包</strong></p><p>入门：</p><p>1.在项目下新建文件夹lib，导入Logback的相关jar包到该目录下，并添加到项目依赖库中去；</p><p>2.将logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）；</p><p>3.在代码中获取日志的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;类对象&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="第十八天"><a href="#第十八天" class="headerlink" title="第十八天"></a>第十八天</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>可以定位文件：进行删除，获取文本信息等操作；</p><p>但不能读写文件内容</p><p>File对象可以定位文件和文件夹</p><p>File封装的对象仅仅是一个路径名，这个路径可以存在也可以不存在；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在操作文件时一定要使用 File.separator 表示分隔符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 path 是实际存在的路径，则该 File 对象表示的是目录；如果 path 是文件名，则该 File 对象表示的是文件。</span></span><br><span class="line"><span class="comment">//支持相对路径（相对到工程下）与绝对路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String path)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//path 是路径名，name 是文件名。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String path, String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dir 是路径对象，name 是文件名。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(File dir, String name)</span>;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>boolean canRead()</td><td style="text-align:center">测试应用程序是否能从指定的文件中进行读取</td></tr><tr><td>boolean canWrite()</td><td style="text-align:center">测试应用程序是否能写当前文件</td></tr><tr><td>boolean delete()</td><td style="text-align:center">删除当前对象指定的文件（占用可删），非空文件夹不能删除；（不走回收站！）</td></tr><tr><td>boolean exists()</td><td style="text-align:center">测试当前 File 是否存在</td></tr><tr><td>String getAbsolutePath()</td><td style="text-align:center">返回由该对象表示的文件的绝对路径名</td></tr><tr><td>String getName()</td><td style="text-align:center">返回表示当前对象的文件名或路径名（如果是路径，则返回最后一级子路径名）</td></tr><tr><td>String getParent()</td><td style="text-align:center">返回当前 File 对象所对应目录（最后一级子目录）的父目录名</td></tr><tr><td>boolean isAbsolute()</td><td style="text-align:center">测试当前 File 对象表示的文件是否为一个绝对路径名。该方法消除了不同平台的差异，可以直接判断 file 对象是否为绝对路径。在 UNIX/Linux/BSD 等系统上，如果路径名开头是一条斜线<code>/</code>，则表明该 File 对象对应一个绝对路径；在 Windows 等系统上，如果路径开头是盘符，则说明它是一个绝对路径。</td></tr><tr><td>boolean isDirectory()</td><td style="text-align:center">测试当前 File 对象表示的文件是否为一个路径</td></tr><tr><td>boolean isFile()</td><td style="text-align:center">测试当前 File 对象表示的文件是否为一个“普通”文件</td></tr><tr><td>long lastModified()</td><td style="text-align:center">返回当前 File 对象表示的文件最后修改的时间</td></tr><tr><td>long length()</td><td style="text-align:center">返回当前 File 对象表示的文件长度</td></tr><tr><td>String[] list()</td><td style="text-align:center">返回当前 File 对象指定的路径文件列表</td></tr><tr><td>String[] list(FilenameFilter)</td><td style="text-align:center">返回当前 File 对象指定的目录中满足指定过滤器的文件列表</td></tr><tr><td>boolean mkdir()</td><td style="text-align:center">创建一个目录，它的路径名由当前 File 对象指定</td></tr><tr><td>boolean mkdirs()</td><td style="text-align:center">创建一个多级目录，它的路径名由当前 File 对象指定</td></tr><tr><td>boolean renameTo(File)</td><td style="text-align:center">将当前 File 对象指定的文件更名为给定参数 File 指定的路径名</td></tr><tr><td>boolean creatNewFile()</td><td style="text-align:center">创建新文件，创建成功返回true，若失败或文件已经存在则返回false（几乎不用）</td></tr><tr><td>File[] listFiles()</td><td style="text-align:center">返回当前目录下所有的”一级文件对象“的一个文件对象数组(常用);调用者不存在，返回null；调用者为一个空文件夹时，返回长度为0的数组；（常用）</td></tr></tbody></table></div><h3 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h3><p>方法直接调用自己，或者间接调用自己的形式称为方法递归(recursion)；</p><p>递归死循环：递归方法无限调用自己，无法终止，出现栈内存溢出；</p><p>递归问题解决的思路：</p><p>~ 把一个复杂的问题层层转化为一个与原问题相似规模较小的问题来解决；</p><p><strong>三要素： 递归公式 递归终点 递归方向 </strong></p><h3 id="文件搜索（方法递归）"><a href="#文件搜索（方法递归）" class="headerlink" title="文件搜索（方法递归）"></a>文件搜索（方法递归）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">目的：从某个盘中，搜索出某个文件名称并输出绝对路径</span></span><br><span class="line"><span class="comment">1.先定位出应该是一级文件对象</span></span><br><span class="line"><span class="comment">2.遍历一遍全部一级文件对象，判断是否为文件</span></span><br><span class="line"><span class="comment">3.如果是文件，判断是否为目标文件</span></span><br><span class="line"><span class="comment">4.如果是文件夹，需要继续递归进去重复上述过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir,String fileName)</span>&#123;</span><br><span class="line">    <span class="comment">//判断dir是否为目录</span></span><br><span class="line">    <span class="keyword">if</span>(dir != <span class="literal">null</span> &amp;&amp; dir.isDirectory)&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(File file : files)&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(file.getName().contains(fileName))&#123;</span><br><span class="line">                        <span class="comment">//输出绝对路径；</span></span><br><span class="line">                        System.out.println(file.getAbsolutePath());</span><br><span class="line">                        <span class="comment">//启动文件</span></span><br><span class="line">                        <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRunTime();</span><br><span class="line">                        r.exec(file.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    searchFile(file,fileName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p><strong>ASCII</strong>字符集：包括了数字，英文，符号，使用一个字节存储一个字符，可以表示128个字符信息；</p><p><strong>GBK</strong>字符集：Windows默认码表，兼容ASCII码表，也包括了几万个汉字，并支持繁体汉字以及部分日韩文字；两个字节表示一个中文；</p><p><strong>Unicode</strong>码表：又称万国码，容纳世界上大多数国家的所有常见位置和符号；三个字节表示一个中文； </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;abc我爱你中国&quot;</span>;<span class="comment">//18个字节</span></span><br><span class="line"><span class="type">byte</span>[] bytes = name.getBytes(<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//以当前代码默认字符集进行编码（UTF-8）</span></span><br><span class="line"><span class="comment">//解码(编码前与编码后的字符集必须一致)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//默认UTF-</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>输入输出流，用来读写数据的；</p><p>按流中数据最小单位划分：字节流，字符流；</p><h4 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h4><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：</p><p>（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</p><p>（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p><p>（3）字节流在操作的时候本身是不会用到缓冲区的，是文件本身的直接操作的；而字符流在操作的时候下后是会用到缓冲区的，是通过缓冲区来操作文件，我们将在下面验证这一点。</p><p>结论：优先选用字节流。首先因为硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符只是在内存中才会形成的，所以在开发中，字节流使用广泛。</p><h4 id="输入字节流InputStream"><a href="#输入字节流InputStream" class="headerlink" title="输入字节流InputStream"></a>输入字节流InputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">FileInputStream</span></span><br><span class="line"><span class="comment">以内存为基准，把磁盘中的数据以字节的形式读取到内存中去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(File file)</span> <span class="comment">//创建字节输入流管道与源文件对象接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String pathName)</span> <span class="comment">//创建字节输入流管道与源文件路径接通</span></span><br><span class="line"><span class="comment">//常用API</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="comment">//每次读取一个字节返回，如果没有字节可以返回，则返回-1；</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> <span class="comment">//每次读取一个字节数组并返回读取长度，如果没有字节可以返回，则返回-1</span></span><br><span class="line"><span class="comment">//循环读入的时候buffer转String时采用 new String(byte[] bytes,int offset,int len)构造，避免数组未读满时，会将上次读取的字节重新转换；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**如何使用字节输入流读取中文内容输出不乱码？</span></span><br><span class="line"><span class="comment">    1.定义一个与文件大小一样大的字节数组，一次性读取完文件所有字节</span></span><br><span class="line"><span class="comment">    带来的问题：如果文件过大，字节数组可能引起内存溢出</span></span><br><span class="line"><span class="comment">    byte[] buffer = (new FileINputStream(String patnName)).readAllBytes;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="输出字节流OutputStream"><a href="#输出字节流OutputStream" class="headerlink" title="输出字节流OutputStream"></a>输出字节流OutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">FileOutputStream</span></span><br><span class="line"><span class="comment">以内存为基准，把内存中中的数据以字节的形式写入到磁盘中去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file)</span> <span class="comment">//创建字节输出流管道与源文件对象接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String pathName)</span> <span class="comment">//创建字节输出流管道与源文件路径接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String pathName，<span class="type">boolean</span> append)</span> <span class="comment">//创建字节输出流管道与源文件路径接通 append为true时追加</span></span><br><span class="line"><span class="comment">//常用API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> a)</span><span class="comment">//将一个字节写出去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer)</span> <span class="comment">//每次输出一个字节数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] bytes,<span class="type">int</span> offset,<span class="type">int</span> len)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span><span class="comment">//刷新流，但能继续写数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span><span class="comment">//关闭流，释放资源，但是会在关闭前刷新流，一旦关闭，则不能继续写数据；</span></span><br><span class="line"><span class="comment">/**如何使用字节输入流读取中文内容输出不乱码？</span></span><br><span class="line"><span class="comment">    1.定义一个与文件大小一样大的字节数组，一次性读取完文件所有字节</span></span><br><span class="line"><span class="comment">    带来的问题：如果文件过大，字节数组可能引起内存溢出</span></span><br><span class="line"><span class="comment">    byte[] buffer = (new FileINputStream(String patnName)).readAllBytes;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//回车用&quot;\r\n&quot;，然后转成字节数组即可</span></span><br></pre></td></tr></table></figure><h4 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h4><p><strong>try-catch-finally</strong></p><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>在关闭流的时候，要对流进行校验是否为空，为空会抛出空指针异常；</p><p><strong>try-with-resource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>( <span class="comment">//这里只能放置资源对象，用完会自动关闭，自动调用对象的close()方法关闭资源，即使出现异常也会关闭</span></span><br><span class="line">        <span class="comment">//资源都是实现了Closeable/AutoCloseable接口的对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.txt&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> input.read();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输入字符流Read"><a href="#输入字符流Read" class="headerlink" title="输入字符流Read"></a>输入字符流Read</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">FileReader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(File file)</span> <span class="comment">//创建字符输入流管道与源文件对象接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String pathName)</span> <span class="comment">//创建字符输入流管道与源文件路径接通</span></span><br><span class="line"><span class="comment">//常用API</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span><span class="comment">//每次读取一个字符返回，如果没有字符可以返回，则返回-1；</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span> <span class="comment">//每次读取一个字符数组并返回读取长度，如果没有字符可以返回，则返回-1</span></span><br></pre></td></tr></table></figure><h4 id="输出字符流Writer"><a href="#输出字符流Writer" class="headerlink" title="输出字符流Writer"></a>输出字符流Writer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">FileWriter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file)</span> <span class="comment">//创建字符输出流管道与源文件对象接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String pathName)</span> <span class="comment">//创建字符输出流管道与源文件路径接通</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String pathName，<span class="type">boolean</span> append)</span> <span class="comment">//创建字符输出流管道与源文件路径接通 append为true时追加</span></span><br><span class="line"><span class="comment">//常用API</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span><span class="comment">//将一个字符写出去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] buffer)</span> <span class="comment">//每次输出一个字符数组，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] bytes,<span class="type">int</span> offset,<span class="type">int</span> len)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> <span class="comment">//每次输出一个字符串，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str,<span class="type">int</span> offset,<span class="type">int</span> len)</span></span><br></pre></td></tr></table></figure><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><p>作用：缓冲流自带缓冲区，可以提高原始字节流，字符流读写数据的性能；</p><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p>自带8KB的缓冲池</p><p><strong>BufferInputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级的字节输入流包装成一个高级的缓冲字节输入管道，从而提高字节输入流读数据的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferInputStream</span><span class="params">(InputStream is)</span></span><br></pre></td></tr></table></figure><p><strong>BufferOutputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级的字节输出流包装成一个高级的缓冲字节输出管道，从而提高字节输出流写数据的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferOutputStream</span><span class="params">(OutputStream os)</span></span><br></pre></td></tr></table></figure><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p><strong>BufferReader</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级的字符输入流包装成一个高级的缓冲字符输入管道，从而提高字符输入流读数据的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferReader</span><span class="params">(Reader r)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增API</span></span><br><span class="line"><span class="comment">//读取一行数据返回，如果读取没有完毕，无行可读返回null</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readLine</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>BufferWriter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级的字符输出流包装成一个高级的缓冲字符输出管道，从而提高字符输出流写数据的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferWriter</span><span class="params">(Writer w)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//新增API</span></span><br><span class="line"><span class="comment">//换行操作</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">newLine</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p><strong>InputStreamReader</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将原始的字节输入流按照代码的默认编码转换成字符输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream is)</span> <span class="comment">//（几乎不用）</span></span><br><span class="line"><span class="comment">//可以将原始的字节输入流按照指定编码转换成字符输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream is，String charset)</span> <span class="comment">//常用</span></span><br></pre></td></tr></table></figure><p><strong>OutputStreamWriter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将原始的字节输出流按照代码的默认编码转换成字符输出流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream os)</span> <span class="comment">//（几乎不用）</span></span><br><span class="line"><span class="comment">//可以将原始的字节输入流按照指定编码转换成字符输出流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream os，String charset)</span> <span class="comment">//常用</span></span><br></pre></td></tr></table></figure><h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>作用：以内存为基准，把内存中的对象存储到磁盘中去，称为对象序列化</p><p><strong>对象字节输出流ObjectOutputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级字节输出流包装成高级的对象字节输出流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream os)</span></span><br><span class="line"><span class="comment">//常用方法 ps:对象如果要序列化，必须实现Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object o)</span></span><br></pre></td></tr></table></figure><h4 id="对象的反序列化"><a href="#对象的反序列化" class="headerlink" title="对象的反序列化"></a>对象的反序列化</h4><p>作用：以内存为基准，把磁盘中的对象数据恢复成内存中的对象，称为对象反序列化</p><p><strong>对象字节输入流ObjectInputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="comment">//可以将低级字节输入流包装成高级的对象字节输入流。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream is)</span></span><br><span class="line"><span class="comment">//常用方法 ps:对象如果要序列化，必须实现Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">readObject</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>关键字transient</strong></p><p>修饰的成员不参与序列化；</p><p><strong>序列化版本号</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化的版本号要与反序列化的版本一致</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID;</span><br></pre></td></tr></table></figure><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>作用：打印流可以实现方便、高效的打印数据到文件中去；</p><p><strong>PrintStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底层包装了缓冲流</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream os)</span><span class="comment">//打印流直接通向字节输出管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(File f)</span><span class="comment">//打印流直接通向文件对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(String filePath)</span><span class="comment">//打印流直接通向文件路径</span></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>PrintWrite</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印功能与PrintStream无区别，只不过支持字符数据输出，而PrintStream只能写字节</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWrite</span><span class="params">(OutputStream os)</span><span class="comment">//打印流直接通向字节输出管道</span></span><br><span class="line"><span class="keyword">public</span> PrintWriteWriter w) <span class="comment">//打印流直接通向字符输出管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWrite</span><span class="params">(File f)</span><span class="comment">//打印流直接通向文件对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWrite</span><span class="params">(String filePath)</span><span class="comment">//打印流直接通向文件路径</span></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>若打印流要进行追加，只能用低级管道构造打印流；</p><p><strong>输出语句重定向</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setOut(PrintSream ps)</span><br></pre></td></tr></table></figure><h4 id="Properties属性集对象"><a href="#Properties属性集对象" class="headerlink" title="Properties属性集对象"></a>Properties属性集对象</h4><p>是Map集合的实现类</p><p>作用：代表一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。</p><p>属性文件：后缀是.properties结尾的文件，内容为key=value，用来做系统配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">setProperty</span><span class="params">(String key, String value)</span>  <span class="comment">//保存一对属性。  (put)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> <span class="comment">//使用此属性列表中指定的键搜索属性值 (get)</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">stringPropertyNames</span><span class="params">()</span>  <span class="comment">//所有键的名称的集合  (keySet())</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(OutputStream out, String comments)</span> <span class="comment">//保存数据到属性文件中去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(Writer fw, String comments)</span> <span class="comment">//保存数据到属性文件中去</span></span><br><span class="line"><span class="comment">//加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(InputStream inStream)</span><span class="comment">//加载属性文件的数据到属性集对象中去</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(Reader fr)</span><span class="comment">//加载属性文件的数据到属性集对象中去</span></span><br></pre></td></tr></table></figure><h4 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h4><p><strong>commons-io</strong>是apache开源基金组织提供的一组有关IO操作的类库，<br>可以挺提高IO功能开发的效率。commons-io工具包提供了很多有关io操作的类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文件中的数据, 返回字符串</span></span><br><span class="line">String <span class="title function_">readFileToString</span><span class="params">(File file, String encoding)</span></span><br><span class="line"><span class="comment">//复制文件</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile, File destFile)</span></span><br><span class="line"><span class="comment">//复制文件夹</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copyDirectoryToDirectory</span><span class="params">(File srcDir, File destDir)</span></span><br><span class="line"><span class="comment">//删除文件夹</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteDirectory</span><span class="params">(File f)</span></span><br></pre></td></tr></table></figure><h2 id="第十九天"><a href="#第十九天" class="headerlink" title="第十九天"></a>第十九天</h2><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p><strong>线程</strong>是一个程序内部的一条执行路径</p><p>main方法的执行就是一条单独的路径</p><p><strong>多线程</strong>是指软硬件上实现多条执行流程的技术</p><h5 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h5><p><strong>方法一：继承Thread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1.定义一个子类MyThread继承线程类Java.lang.Thread，重写run()方法</span></span><br><span class="line"><span class="comment">2.创建MyThread类的对象</span></span><br><span class="line"><span class="comment">3.调用线程对象的start()方法启动线程(启动之后还是执行run方法)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//new一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优缺点</span></span><br><span class="line"><span class="comment">//优点：编码简单</span></span><br><span class="line"><span class="comment">//缺点：线程类以及继承Thread，无法继承其他类，不利于扩展</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么不直接调用run方法，而是调用start启动线程？</span></span><br><span class="line"><span class="comment">//调用run方法会被当成单线程，而不是多线程！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么不能把主线程的任务放在子线程之前？</span></span><br><span class="line"><span class="comment">//这样的话主线程一直都是先跑完的，相当于一个单线程的效果</span></span><br></pre></td></tr></table></figure><p><strong>方法二 实现Runnable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">实现方案一：</span></span><br><span class="line"><span class="comment">1.定义一个线程任务类实现Runnable接口，重写run()方法</span></span><br><span class="line"><span class="comment">2.创建MyRunnable任务对象</span></span><br><span class="line"><span class="comment">3.把任务对象交给Thread处理</span></span><br><span class="line"><span class="comment">4.调用线程对象的start()方法启动线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//new一个任务对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Thread构造器，构造一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">实现方案二（匿名内部类）：</span></span><br><span class="line"><span class="comment">1.创建Runnable的匿名内部类</span></span><br><span class="line"><span class="comment">2.把任务对象交给Thread处理</span></span><br><span class="line"><span class="comment">3.调用线程对象的start()方法启动线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//new一个Runnable实例（匿名内部类重写run()方法）</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Thread构造器，构造一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thread构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(String name)</span><span class="comment">//为当前线程指定名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span><span class="comment">//封装Runnable对象为线程对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target,String name)</span><span class="comment">//封装Runnable对象尾线程对象，并指定线程名称    </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//优缺点</span></span><br><span class="line"><span class="comment">//优点线程任务类只是实现接口，可以继承类和实现接口，拓展性强。</span></span><br><span class="line"><span class="comment">//缺点编程多一层对象包装，如果线程有执行结果是不可以直接返回的（run()方法无返回值）</span></span><br></pre></td></tr></table></figure><p><strong>方法三 Callable，FutureTask接口</strong></p><p>方法一和方法二都存在一个问题：无返回结果！</p><p>解决方法：Callable和FutureTask来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**：</span></span><br><span class="line"><span class="comment">1.定义一个线程任务类实现Callable接口，重写call()方法</span></span><br><span class="line"><span class="comment">2.用FutureTask把Callable对象封装成线程任务对象</span></span><br><span class="line"><span class="comment">3.把任务对象交给Thread处理</span></span><br><span class="line"><span class="comment">4.调用线程对象的start()方法启动线程</span></span><br><span class="line"><span class="comment">5，线程执行完毕后，通过FutureTask的get()方法去获取任务执行结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    pubulic <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;子线程执行的结果是&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//new一个Callable任务对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将Callable对象交给FutureTask对象  </span></span><br><span class="line">        <span class="comment">//FutureTask作用1：是Runnable的对象，实现了Runnable接口，可以交给Thread；</span></span><br><span class="line">        <span class="comment">//FutureTask作用2：可以在线程执行完毕之后通过调用其get方法得到线程执行完成的结果；</span></span><br><span class="line">        FutureTask&lt;String&gt; f = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用Thread构造器，构造一个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取返回值</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果f任务未执行完毕，这里代码会等待到任务执行完毕才提取结果；</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> f.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优缺点</span></span><br><span class="line"><span class="comment">//优点线程任务类只是实现接口，可以继承类和实现接口，拓展性强。</span></span><br><span class="line"><span class="comment">// 可以在线程执行完毕后去获取线程执行结果</span></span><br><span class="line"><span class="comment">//缺点代码复杂</span></span><br></pre></td></tr></table></figure><h4 id="Thread类常用API"><a href="#Thread类常用API" class="headerlink" title="Thread类常用API"></a>Thread类常用API</h4><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>public void interrupt()</strong> 中断线程。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td></tr></tbody></table></div><p><strong>静态方法</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>序号</strong></th><th style="text-align:left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td></tr></tbody></table></div><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多个线程同时操作同一个共享资源的时候可能会出现业务安全问题。</p><p>原因：存在多线程并发，同时访问共享资源，存在修改共享资源；                    </p><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>· 为了解决线程安全问题</p><p>· 让多个线程实现先后依次访问共享资源，这样就解决了安全问题；</p><p><strong>核心思想</strong></p><p>1.加锁    把共享资源进行上锁，每次只能 一个线程进入访问，访问完毕以后解锁，然后其他线程才能进来；</p><p><strong>方法一：同步代码块</strong></p><p>作用：把出现线程安全问题的核心代码给上锁</p><p>原理：每次只能 一个线程进入访问，访问完毕以后解锁，然后其他线程才能进来；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(同步锁对象)&#123;</span><br><span class="line">    <span class="comment">//操作共享资源的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//锁对象要求：对于当前同时执行的线程来说是同一个对象即可；-&gt;用字符串命名</span></span><br><span class="line"><span class="comment">//不能使用在方法内new出来的对象，这样对于当前同时执行的线程来说就不是同一个对象；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//锁对象用任意唯一的对象的问题：会影响到其他无关线程执行；</span></span><br><span class="line"><span class="comment">//规范上：建议使用共享资源作为锁对象</span></span><br><span class="line"><span class="comment">//对于实例方法建议使用this作为锁对象</span></span><br><span class="line"><span class="comment">//对于静态方法建议使用字节码（类名.class）对象作为锁对象</span></span><br></pre></td></tr></table></figure><p><strong>方法二：同步方法</strong></p><p>作用：把出现线程安全问题的核心方法给上锁</p><p>原理：每次只能 一个线程进入访问，访问完毕以后解锁，然后其他线程才能进来；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">修饰符 synchronized 返回值类型 方法名称(形参列表)&#123;</span></span><br><span class="line"><span class="comment">操作共享资源的代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//底层原理：隐式锁对象，只是锁的范围是整个方法代码。</span></span><br><span class="line"><span class="comment">//如果方法是实例方法：同步方法默认用this作为锁的对象，但是代码要高度面向对象。</span></span><br><span class="line"><span class="comment">//如果方法是静态方法：同步方法默认用类名.class作为锁的对象。</span></span><br></pre></td></tr></table></figure><p><strong>同步代码块锁的范围更小，同步方法锁的范围更大</strong></p><p><strong>方法三：Lock锁</strong></p><p>· 为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便。</p><p>· Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</p><p>· Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取实现类对象（通常用final修饰）</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//API</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> <span class="comment">//获得锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span><span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure><h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>线程间相互发送数据；</p><p><strong>常见形式</strong></p><p>1.通过共享一个数据的方式实现</p><p>2.根据共享数据的情况决定自己该怎么做，已经通知其他线程怎么做</p><p><strong>线程通信实际应用场景</strong></p><p>1.生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费生产者产生的数据。</p><p>​    要求：生产者线程生产完数据后唤醒消费者，然后等待自己，消费者消费完该数据后唤醒生产者，然后等待自己。</p><h4 id="Object类等待和唤醒方法"><a href="#Object类等待和唤醒方法" class="headerlink" title="Object类等待和唤醒方法"></a>Object类等待和唤醒方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span><span class="comment">//让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span><span class="comment">//唤醒正在等待的单个线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span><span class="comment">//唤醒正在等待的所有线程 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：上述方法应该使用当前同步锁对象进行调用。</span></span><br></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>可以复用线程的技术</p><p><strong>不使用线程池的问题</strong></p><p>如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</p><p><strong>线程池实现的API，参数说明</strong></p><p>接口：ExecutorService</p><p><strong>如何得到线程池对象</strong></p><p>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象（推荐使用，参数可控）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,                  //指定线程池的线程数量（核心线程）不能小于零        </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,               //指定线程池可支持的最大线程数 最大数量大于核心线程数 </span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,                //指定临时线程的最大存活时间  不能小于零         </span></span><br><span class="line"><span class="params">                          TimeUnit unit,                     //指定存活时间的单位时间单位    </span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, //指定任务队列  不能为<span class="literal">null</span>        </span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,       //指定用哪个线程工厂创建线程  不能为<span class="literal">null</span>         </span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>  <span class="comment">//指定线程忙任务满的时候，新任务解决方式 不能为null</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>新任务拒绝策略</p><div class="table-container"><table><thead><tr><th>策略</th><th>详解</th></tr></thead><tbody><tr><td>ThreadPoolExecutor.AbortPolicy</td><td>丢弃任务并抛出RejectedExecutionException异常。<strong>是默认的策略</strong></td></tr><tr><td>ThreadPoolExecutor.DiscardPolicy：</td><td>丢弃任务，但是不抛出异常  这是不推荐的做法</td></tr><tr><td>ThreadPoolExecutor.DiscardOldestPolicy</td><td>抛弃队列中等待最久的任务  然后把当前任务加入队列中</td></tr><tr><td>ThreadPoolExecutor.CallerRunsPolicy</td><td>由主线程负责调用任务的run()方法从而绕过线程池直接执行</td></tr></tbody></table></div><p>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象（不推荐使用）</p><p>Executors：线程池的工具类通过调用方法返回不同类型的线程池对象。</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名称</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">public  static ExecutorService newCachedThreadPool()</td><td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。</td></tr><tr><td style="text-align:left">public static ExecutorService newFixedThreadPool(int nThreads)</td><td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td></tr><tr><td style="text-align:left">public  static ExecutorService newSingleThreadExecutor ()</td><td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td></tr><tr><td style="text-align:left">public  static ExecutorService newScheduledThreadPool(int corePoolSize)</td><td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td></tr></tbody></table></div><p><strong>注意：Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的</strong></p><p><strong>Executor使用可能存在的陷阱</strong></p><p>大型并发系统环境中使用Executors如果不注意可能会出现系统风险。</p><div class="table-container"><table><thead><tr><th>方法名称</th><th>存在问题</th></tr></thead><tbody><tr><td>public  static ExecutorService newFixedThreadPool(int nThreads)</td><td>允许请求的任务队列长度是Integer.MAX_VALUE，可能出现OOM错误（ java.lang.OutOfMemoryError ）</td></tr><tr><td>public  static ExecutorService newSingleThreadExecutor()</td><td></td></tr><tr><td>public  static ExecutorService newCachedThreadPool()</td><td>创建的线程数量最大上限是Integer.MAX_VALUE，  线程数可能会随着任务1:1增长，也可能出现OOM错误（ java.lang.OutOfMemoryError ）</td></tr><tr><td>public  static ExecutorService newScheduledThreadPool(int corePoolSize)</td></tr></tbody></table></div><p><strong>常见问题：</strong></p><p><strong>1.临时线程什么时候创建啊？</strong></p><p>新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。</p><p><strong>2.什么时候会开始拒绝任务？</strong></p><p>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。</p><p><strong>ExecutorService常用API</strong></p><div class="table-container"><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行任务/命令，没有返回值，一般用来执行  Runnable 任务</td></tr><tr><td>Future<T>  submit(Callable<T> task)</td><td>执行任务，返回未来任务对象获取线程结果，一般拿来执行  Callable 任务</td></tr><tr><td>void  shutdown()</td><td>等任务执行完毕后关闭线程池</td></tr><tr><td>List<Runnable>shutdownNow()</td><td>立刻关闭，停止正在执行的任务，并返回队列中未执行的任务</td></tr></tbody></table></div><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>定时器是一种控制任务延时调用，或周期调用技术。</p><p>作用：闹钟、定时邮件发送。</p><p><strong>实现方式</strong></p><p>1.Timer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//API</span></span><br><span class="line"><span class="comment">//开启一个定时器，按照计划处理TimerTask任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,<span class="type">long</span> delay,<span class="type">long</span> period)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//特点：</span></span><br><span class="line"><span class="comment">//Timer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</span></span><br><span class="line"><span class="comment">//问题：</span></span><br><span class="line"><span class="comment">//可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.ScheduledExecutorService</p><p>ScheduledExecutorService是 jdk1.5中引入了并发包，<strong>目的是为了弥补Timer的缺陷,</strong> ScheduledExecutorService内部为线程池。</p><div class="table-container"><table><thead><tr><th>Executors的方法</th><th>说明</th></tr></thead><tbody><tr><td>public static ScheduledExecutorService <strong>newScheduledThreadPool</strong>(int corePoolSize)</td><td>得到线程池对象</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>ScheduledExecutorService的方法</th><th>说明</th></tr></thead><tbody><tr><td>public ScheduledFuture&lt;?&gt; <strong>scheduleAtFixedRate</strong>(Runnable command, long initialDelay, long period,                              TimeUnit unit)</td><td>周期调度方法</td></tr></tbody></table></div><p><strong>ScheduledExecutorService的优点</strong></p><p>1、基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</p><h4 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发 并行"></a>并发 并行</h4><p>正在运行的程序（软件）就是一个独立的进程， 线程是属于进程的，多个线程其实是并发与并行同时进行的。</p><p><strong>并发的理解</strong></p><p>1.CPU同时处理线程的数量有限。</p><p>2.CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p><strong>状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6种状态都定义在Thread类的内部枚举类中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">     ...  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;    </span><br><span class="line">     NEW,   </span><br><span class="line">     RUNNABLE,    </span><br><span class="line">     BLOCKED,    </span><br><span class="line">     WAITING,   </span><br><span class="line">     TIMED_WAITING,   </span><br><span class="line">     TERMINATED;    </span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二十天"><a href="#第二十天" class="headerlink" title="第二十天"></a>第二十天</h2><h3 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h3><pre><code>* 测试分类：    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。    2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试    * 步骤：        1. 定义一个测试类(测试用例)            * 建议：                * 测试类名：被测试的类名Test        CalculatorTest                * 包名：xxx.xxx.xx.test        cn.itcast.test        2. 定义测试方法：可以独立运行            * 建议：                * 方法名：test测试的方法名        testAdd()                  * 返回值：void                * 参数列表：空参        3. 给方法加@Test        4. 导入junit依赖环境    * 判定结果：        * 红色：失败        * 绿色：成功        * 一般我们会使用断言操作来处理结果            * Assert.assertEquals(期望的结果,运算的结果);    * 补充：        * @Before:            * 修饰的方法会在测试方法之前被自动执行        * @After:            * 修饰的方法会在测试方法执行之后自动被执行</code></pre><h3 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h3><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制    * 好处：        1. 可以在程序运行过程中，操作这些对象。        2. 可以解耦，提高程序的可扩展性。* 获取Class对象的方式：    1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类    2. 类名.class：通过类名的属性class获取        * 多用于参数的传递    3. 对象.getClass()：getClass()方法在Object类中定义着。        * 多用于对象的获取字节码的方式    * 结论：        同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。* Class对象功能：    * 获取功能：        1. 获取成员变量们            * Field[] getFields() ：获取所有public修饰的成员变量            * Field getField(String name)   获取指定名称的 public修饰的成员变量            * Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符            * Field getDeclaredField(String name)          2. 获取构造方法们            * Constructor&lt;?&gt;[] getConstructors()              * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)              * Constructor&lt;?&gt;[] getDeclaredConstructors()          3. 获取成员方法们：            * Method[] getMethods()              * Method getMethod(String name, 类&lt;?&gt;... parameterTypes)              * Method[] getDeclaredMethods()              * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)          4. 获取全类名                * String getName()  * Field：成员变量    * 操作：        1. 设置值            * void set(Object obj, Object value)          2. 获取值            * get(Object obj)         3. 忽略访问权限修饰符的安全检查            * setAccessible(true):暴力反射* Constructor:构造方法    * 创建对象：        * T newInstance(Object... initargs)          * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法* Method：方法对象    * 执行方法：        * Object invoke(Object obj, Object... args)      * 获取方法名称：        * String getName:获取方法名* 案例：    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法        * 实现：            1. 配置文件            2. 反射        * 步骤：            1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中            2. 在程序中加载读取配置文件            3. 使用反射技术来加载类文件进内存            4. 创建对象            5. 执行方法</code></pre><h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><pre><code>* 概念：说明程序的。给计算机看的* 注释：用文字描述程序的。给程序员看的* 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。* 概念描述：    * JDK1.5之后的新特性    * 说明程序的    * 使用注解：@注解名称</code></pre><p>​    </p><pre><code>* 作用分类：    ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】    ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】    ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】* JDK中预定义的一些注解    * @Override    ：检测被该注解标注的方法是否是继承自父类(接口)的    * @Deprecated：该注解标注的内容，表示已过时    * @SuppressWarnings：压制警告        * 一般传递参数all  @SuppressWarnings(&quot;all&quot;)* 自定义注解    * 格式：        元注解        public @interface 注解名称&#123;            属性列表;        &#125;    * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口        * public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125;    * 属性：接口中的抽象方法        * 要求：            1. 属性的返回值类型有下列取值                * 基本数据类型                * String                * 枚举                * 注解                * 以上类型的数组            2. 定义了属性，在使用时需要给属性赋值                1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。                2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。                3. 数组赋值时，值使用&#123;&#125;包裹。如果数组中只有一个值，则&#123;&#125;可以省略    * 元注解：用于描述注解的注解        * @Target：描述注解能够作用的位置            * ElementType取值：                * TYPE：可以作用于类上                * METHOD：可以作用于方法上                * FIELD：可以作用于成员变量上        * @Retention：描述注解被保留的阶段            * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到        * @Documented：描述注解是否被抽取到api文档中        * @Inherited：描述注解是否被子类继承* 在程序使用(解析)注解：获取注解中定义的属性值    1. 获取注解定义的位置的对象  （Class，Method,Field）    2. 获取指定的注解        * getAnnotation(Class)        //其实就是在内存中生成了一个该注解接口的子类实现对象                public class ProImpl implements Pro&#123;                    public String className()&#123;                        return &quot;cn.itcast.annotation.Demo1&quot;;                    &#125;                    public String methodName()&#123;                        return &quot;show&quot;;                    &#125;                &#125;    3. 调用注解中的抽象方法获取配置的属性值* 案例：简单的测试框架* 小结：    1. 以后大多数时候，我们会使用注解，而不是自定义注解    2. 注解给谁用？        1. 编译器        2. 给解析程序用    3. 注解不是程序的一部分，可以理解为注解就是一个标签</code></pre><h1 id="Java基础完结！！！！！！！！！！！！！！！"><a href="#Java基础完结！！！！！！！！！！！！！！！" class="headerlink" title="Java基础完结！！！！！！！！！！！！！！！"></a>Java基础完结！！！！！！！！！！！！！！！</h1>]]></content>
    
    
    <summary type="html">Java基础的学习笔记</summary>
    
    
    
    <category term="后台成长历程" scheme="https://blog.hiles.cn/categories/%E5%90%8E%E5%8F%B0%E6%88%90%E9%95%BF%E5%8E%86%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://blog.hiles.cn/tags/java/"/>
    
  </entry>
  
</feed>
